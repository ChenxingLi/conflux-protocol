% !TEX root = ./tech-specification.tex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{合约创建}
%\subsection{Contract Creation}
\label{sec:creation}

当创建一个智能合约账户时，我们使用若干固有参数：
%A number of intrinsic parameters are used when creating a smart contract account:
\begin{itemize}[nosep]
	\item 世界状态 ${\st}$;
	%\item world-state ${\st}$;
	
	\item 发送方 $s$;
	%\item sender $s$;

	\item 原发送方 $o$;
	%\item original sender $o$;
	
	\item 调用栈中其他参与方 $\vec{t}$;
	%\item other recipients in call stack $\vec{t}$;
	
	\item 存储所有者 $i$;
	%\item storage owner $i$;
		
	\item 可用燃料 $g$;
	%\item available gas $g$;

	% \item storage limit $\ell$;

	\item 燃料价格 $p$;
	%\item gas price $p$;

	\item 资助额 $v$;
	%\item endowment $v$;

	\item 表示初始化代码的任意长度字节数组 $\vec{i}$ ;
	%\item initialization code $\vec{i}$ as an arbitrary length byte array;

	\item 当前消息调用栈/合约创建栈的深度 $e$;
	%\item the present depth of message-call/contraction-creation stack $e$;

	\item 新账户地址的salt $\zeta$，\\
	其中，若 {\hyperlink{create}{$\op{CREATE}$}} 使得合约创建，则 $\zeta = \varnothing$；
	若 {\hyperlink{create2}{$\op{CREATE2}$}} 使得合约创建，则 $\zeta\in \B_{256}$；
	%\item the salt for new account's address $\zeta$,\\
	%where $\zeta = \varnothing$ if the creation was caused by {\hyperlink{create}{$\op{CREATE}$}}, 
	%and $\zeta\in \B_{256}$ if the creation was caused by {\hyperlink{create2}{$\op{CREATE2}$}};

	\item 以及，改变状态的许可 $w$.
	%\item and finally the permission to change the state $w$.
\end{itemize}


我们使用 $\creation$ 表示合约创建函数，
%We define the contract creation function by $\creation$,
该函数根据以上参数，评估并修改状态 $\st$ 为新状态 $\st'$，并一起返回剩余燃料 $g'$、累计子状态 $A$、合约创建结果 $\zeta$ 和输出 $\vec{o}$。
%which evaluates from the above parameters and modifies the state $\st$ to a new state $\st'$, together with the leftover gas $g'$, the accrued substate $A$, the result of creation, and the output $\vec{o}$. 
\begin{align}
	\left(\st',g', A, z, \vec{o} \right)\eqdef \creation\left(\st, s, o, \vec{t},i, g, p, v, \vec{i}, e, \zeta,w \right)
\end{align}

由 {\hyperlink{create}{$\op{CREATE}$}} 新创建的账户 $\account$ 的地址 $a$ 由一个 $4$ 位合约类型标志，一个 Keccak 哈希值的最右 $156$ 位（即第 $100$ 至 $255$ 位）连接而成。该哈希值对一个零字节，发送方地址 $s$，账户序列号的小端字节序 $32$ 字节数组，和 \cvm 代码的 Keccak 哈希
???
The address $a$ of the account $\account$ newly created by {\hyperlink{create}{$\op{CREATE}$}} is defined as the $4$-bit contract type indicator concatenating the rightmost $156$ bits (i.e. the $100$-th to $255$-th bit) of the Keccak hash of a zero byte, the sender address $s$, the little-endian 32-byte array of its account nonce and the Keccak hash of \cvm code. 
% 
而由 {\hyperlink{create2}{$\op{CREATE2}$}} 新创建的账户地址稍不同于前一种，其用salt $\zeta$ 代替账户序列号，并在取 Keccak 哈希值之前改变leading字节 (following EIP-1014)
？？？？
For {\hyperlink{create2}{$\op{CREATE2}$}} the rule is slightly different by substituting account nonce with the salt $\zeta$ and changing the leading byte before taking Keccak (following EIP-1014).
综合两种情况，新合约账号 $\account$ 的地址定义如下：
%Combining these two cases, the resultant address for the new contract account $\account$ is defined as follows:
\begin{align}\label{eq:new-address}
	a= A(s, \st[s]_{n} - 1, \zeta, \vec{i}) \eqdef 
	\left\{\begin{array}{l l l l l}
	 	\typecontract \circ \kec\big([\mathrm{00}]_{16} &~\circ~ s &\circ~ \mathrm{LE}_{32}(\st[s]_n-1) &\circ~ \kec(\vec{i}) \big)[100 \dots 255]
	 	& \text{if}\ \zeta = \varnothing \\
	 	\typecontract \circ \kec\big([\mathrm{ff}]_{16} &~\circ~ s &\circ~  \zeta   &\circ~ \kec(\vec{i}) \big)[100 \dots 255] 
		& \text{otherwise}
	\end{array} \right.
\end{align}
其中 $\mathrm{LE}_{32}(\cdot)$ 代表一个函数，其将一个整数值扩为一个 $32$ 位小端字节序的字节数组。
%where $\mathrm{LE}_{32}(\cdot)$ denotes the function that expands an integer value in $[0,2^{256}-1]$ to a little-endian 32-byte array. 
%
需注意的是，我们使用 $\st[s]_n-1$ 的原因是，它等于相应的交易或 VM 操作生成时的发送方序列号。
%Note that we use $\st[s]_n-1$ since it is indeed the sender's nonce at the generation of the respective transaction or VM operation. 

若 $\st[a]_c\neq \kec(\emptystring)$，系统将触发一个 \emph{合约地址冲突} 例外。此情况发生时，函数 $\creation$ 将立刻返回 $(\varnothing,g,A^0,1)$。
%If $\st[a]_c\neq \kec(\emptystring)$, a \emph{Contract Address Conflict} exception is triggered. Function $\creation$ returns $(\varnothing,g,A^0,1)$ immediately. 

否则，账户序列号将初始化为一，账户余额根据合约创建交易设置，存储项和代码项皆设为空白字符串。
%Otherwise, the account's nonce is initialized to one, the balance as the value passed by the contract creation transaction, the storage and code as for the empty string.
发送者的余额根据转账额减少（交易执行需要余额足够）。
%The sender's balance is reduced by the transferred value (there must be enough balance or the transaction will not be executed).
因此，转变后的状态 $\st^*$ 为
%Thus the mutated state becomes $\st^*$:
\begin{align}
	\st^* & \eqdef \st \qquad{ \text{except:}}\\
	\st^*[a] &\eqdef \account^0 \quad\text{except:}\; \st^*[a]_n=1 \wedge \st^*[a]_b=v+\st[a]_b \wedge \st^*[a]_a=o\\
	% \left(a, \account_{state}\right)\\
	\st^*[s] &\eqdef \begin{cases}
		\varnothing & \mbox{if $\st[s]=\varnothing$ $\land$ $v=0$}\\
		\st[s]\quad\mbox{except}:	\st^*[s]_b=\st[s]_b-v	& \mbox{otherwise}
	\end{cases}
\end{align}
其中，$\account^0$ 为默认账户（详见 \cref{eq:default_account}）。
where $\account^0$ is the default account specified in~\cref{eq:default_account}. 

其他未提及的账户组成部分将初始化为默认值。
%The unmentioned components of an account are initialized by default.

最后，账户 $\account$ 将根据执行模型由 \cvm 代码 $\vec{i}$ 初始。
%Finally the account $\account$ is initialized by \cvm code $\vec{i}$ according to the execution model.
代码执行可能会影响执行状态外部的数个环节：
%Code execution may effect several events that are not internal to the execution state:
账户的存储可以被改变，可以创建更多账户，进行更多消息调用。
%the account's storage can be altered, further accounts can be created and further messages calls can be made.
如此，代码执行函数 $\execute$ 
？？？ evaluate to
包含结果状态 $\st^{**}$，剩余可用燃料 $g^{**}$，累计子状态 $A$，和主体代码 $\vec{o}$ 的多元组。
As such, the code execution function $\execute$ evaluates to a tuple of resultant state $\st^{**}$, available gas remaining $g^{**}$, the accrued substate $A$ and the body code $\vec{o}$.
\begin{align}
	\left(\st^{**}, g^{**},  A, \vec{o} \right) \eqdef \execute\left(\st^*, g, I\right)
\end{align}
where $I$ consists of the parameters of the execution environment as follows:
\begin{align}
	I_a &\eqdef a\\
	I_o &\eqdef o\\
	I_i &\eqdef i\\
	I_p &\eqdef p\\
	I_\vec{d} &\eqdef \emptystring\\
	I_\vec{t} & \eqdef \vec{t}\\
	I_s &\eqdef s\\
	I_v &\eqdef v\\
	I_\vec{b} &\eqdef \vec{i}\\
	I_{\head} & \eqdef \head \\
	I_\vec{L} & \eqdef \vec{L} \\ 
	I_e &\eqdef e\\
	I_w &\eqdef w
\end{align}

$I_{\vec{d}}$ evaluates to the empty tuple as there is no input data to this call. 
$I_{\head}$ is the block header of the present block.
$I_\vec{L}$ is the list of block headers ordered in front of the current block.

Code execution depletes gas, and gas may not go below zero, thus the actual execution may exit before the code has come to a natural halting state.
In this (and several other) exceptional cases (i.e. $\st^{**}=\varnothing \land \vec{o}=\varnothing$), we say an out-of-gas (OOG) exception has occurred:
the evaluated state is set to the empty set $\varnothing$, 
and the entire contract creation should have no effect on the state, effectively leaving it as it was immediately prior to the attempt of the failed creation.
%
Function $\creation$ returns $(\varnothing,g^{**},A^0,1)$ immediately. 


If the initialization code completes successfully,
a final storage cost is charged for depositing the code.
The storage cost $s$ is proportional to the code size of the created contract and it consists of two parts:
\begin{itemize}
	\item the code-deposit cost $d$ charged as gas consumption:
	\begin{align}
		d \eqdef   |\vec{o}| \times G_{codedeposit}
	\end{align}

	\item a substate $A^{*}$ will be generated to record the storage occupied by code size. the code size collateral will be charged in transaction post processing and will be locked during the lifetime of the created contract. (Conflux will record the owner of code in world-state and refund the collateral when the contract is destroyed):
	\begin{align}
		A^{*} \eqdef   A^0 \quad\mbox{except: }A^*_{\bf p}[i]=|\vec{o}|
	\end{align}
\end{itemize}


If the remaining gas cannot afford the code-deposit cost (i.e. $g^{**}<d$) or the code size exceeds 49152 bytes (i.e. $|\vec{o}|<49152$), then we also declare that an exception occurs and handle it as a failed contract creation attempt. 
%
Function $\creation$ returns $(\varnothing,g^{**},A^0,1)$ immediately. 

If the contract creation fails for any reason, the value of the transaction is not transferred to the aborted contract, and collateral for storing the code is not locked either.
If the contract creation succeeds, we formally specify the resultant state, gas, storage limit, substate, and status code by $\left(\st', g', A', z\right)$ as follows:
\begin{align}
	g' &\eqdef g^{**}-d \\
	\st' &\eqdef \st^{**} \quad\mbox{except:} \\
		\st'[a]_c &\eqdef \kec(\vec{o}) \\ 
		\st'[a]_{code} &\eqdef (\vec{o},i) \\
	\notag \\
	A^* &\eqdef A^0 \quad\mbox{except:} \\
	A_{\bf c}[a] &\eqdef |\vec{o}|\times \collateralperbyte \\
	A' &\eqdef A \Cup A^{*} \\ 
	z &\eqdef 0
\end{align}

In the determination of $\st'$, the final body code for the newly created account is specified by the byte sequence $\vec{o}$ derived from the execution of the initialization code $\vec{i}$.
The status code $z$ is an indicator of whether the contract creation succeeds.

Therefore the result of contract creation is either a successfully created new contract with its endowment and collateral for storage, or no new contract and no transfer of value or collateral at all.

\paragraph{Subtleties.} 
Note that while the initialization code is executing, the newly created address exists but with no intrinsic body code. 
Thus any message call received by it during this time causes no code to be executed. 
If the initialization execution ends with a $\op{SUICIDE}$ instruction, the matter is moot since the account will be deleted before the transaction is completed. 
For a normal $\op{STOP}$ code, or if the code returned is otherwise empty, then the world-state may left with a zombie account. Only the administrator of such contract can destroy it by calling the internal contract described in \cref{sec:admin}.
