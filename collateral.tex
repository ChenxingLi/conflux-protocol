% !TEX root=./tech-specification.tex

\section{存储抵押}
%\section{Collateral for Storage}
\label{sec:collateral}

作为存储使用的定价方法 

Conflux 采用 \emph{存储抵押} （缩写为 CFS） 机制作为存储费用的定价方式，相比于以太坊所用的一次性存储费，它更加公平合理。
%\emph{Collateral for storage} (CFS for short) mechanism is introduced in \name as a pricing method for the usage of storage,
%which is more fair and reasonable than the one-off storage fee in Ethereum. 
% 
理论上，该机制对任何存储空间的使用都要求一笔资金被锁为抵押。
%In principle, this mechanism requires a fund being locked as collateral for any occupation of storage space.
抵押资金将被锁定至其对应的存储被释放或被他人盖写。为了维护存储空间，由锁定抵押产生的利润将被直接分配给矿工。
%The collateral is locked until the corresponding storage is freed or overwritten by someone else,
%and the corresponding interest generated by the locked collateral is assigned directly to miners for the maintenance of storage.
因此，Conflux 的存储费用同样取决于使用存储空间的时长。
%Thus, the cost of storage in \name also depends on the duration of space occupation. 

\name 的每项存储为 \sunitsize，也即世界状态里单个键值对的大小。
%In \name, every entry of storage is \sunitsize, which is exactly the size of a single key/value pair in the world-state.
存储所需的抵押与能够覆盖所有待存储项的 \sunitsize 最小倍数成正比。
%The required collateral for storage is proportional to the smallest multiple of \sunitsize that are capable to cover all stored items.
对于每项存储而言，最后写入该项的账户被称为 \emph{该存储项的所有者}。
%For every storage entry, the account that last writes to the entry is called \emph{the owner of that storage entry}.
若存储项在一个有抵押赞助的合约 $\contract$ 执行过程中被写入，
%If a storage entry is written in the execution of a contract $\contract$ with sponsorship for collateral, 
则 $\contract$ 将作为写入该项的账户，并因此成为该项的所有者（更多细节详见第 \ref{sec:sponsor} 节）。
%then $\contract$ is regarded as the account writing to that entry and hence becomes the owner accordingly (see Section~\ref{sec:sponsor} for more details).
世界状态中一个存储项的完整使用期限内，
%In the whole lifetime of a storage entry in the world-state, 
该项所有者必须锁定一笔定额的 \cfx 作为占用存储空间的抵押。
%the owner of that entry must lock a fixed amount of \cfx as collateral for the occupation of storage space. 
特别地，对每个大小为 \sunitsize 的存储项，所有者必须锁定 \sunitprice。
%In particular, for each storage entry of size \sunitsize the owner should lock \sunitprice. 
该价格本质上是对每 \storagepertoken 付出 $1$ \cfx，即存储的每个字节需要 $10^{18}/\storagebytepertoken$ \unit。
%This price is essentially $1$ \cfx for \storagepertoken space,
%i.e. every byte of storage requires $10^{18}/\storagebytepertoken$ \unit.

当账户 $\account$ 成为一个存储项的所有者（在该项创建或修改时），$\account$ 应当在交易执行完成后为该项锁定 \sunitprice。
%At the time that an account $\account$ becomes the owner of a storage entry (at either creation or modification), $\account$ should lock \sunitprice for that entry at the end of transaction execution.
若 $\account$ 是一个普通地址，被锁定的 \sunitprice 将从其余额扣除。若 $\account$ 是一个合约地址，被锁定的 \sunitprice 将从其 \textbf{存储抵押资助余额} 扣除。
%If $\account$ is a normal address, the locked \sunitprice is deducted from its balance. If $\account$ is a contract address, the locked \sunitprice is deducted from its \textbf{sponsor balance for collateral}.
若 $\account$ 有足够余额，所需的抵押将被自动锁定。若 $\account$ 没有足够余额，整个交易执行将失败。
%If $\account$ has enough balance then the required collateral is locked automatically,
%otherwise if $\account$ does not have enough balance, the whole transaction execution will fail.

当一个存储项从世界状态被删除时，其对应的 \sunitprice 抵押将被释放并退回该项所有者的余额。
%When a storage entry is deleted from the world-state, the corresponding \sunitprice collateral is unlocked and returned to the balance of that entry's owner.
若一个存储项的所有权有所变动，前所有者的 \sunitprice 质押将被释放，而现所有者必须同时重新锁定 \sunitprice 作为抵押。
%In case the ownership of a storage entry is changed, the old owner's \sunitprice collateral is unlocked, while the new owner must lock \sunitprice as collateral at the same time.

为了简便性，我们采用函数 $\cfs$。该函数将一个账户地址 $a$ 和世界状态 $st$ 当作输入，返回世界状态 $st$ 下账户 $a$ 被锁定的存储抵押全额（以 \unit 为单位）。
%For convenience, we introduce the function $\cfs$ which takes an account address $a$ and a world-state $\st$ as input and returns the total amount of \unit's of locked collateral for storage of account $a$ in world-state $\st$.
当世界状态 $\st$ 在上下文中没有歧义时，我们用 $\cfs(a)$ 代替 $\cfs(a;\st)$ 来简洁表达。
%In case the world-state $\st$ is clear from context, we write $\cfs(a)$ instead of $\cfs(a;\st)$ for succinctness.

\begin{align}
	\cfs(a) \eqdef \cfs(a;\st) \eqdef \st[a]_o
\end{align}

世界状态也留有被锁定的抵押代币全额，该值被存储在 staking 内部合约的存储项中。我们使用函数 ${\sf ACFS}$ 来从世界状态 $\st$ 读取该值。
%The world state also maintains the total number of locked tokens for collateral, which is stored in storage entry of staking internal contract. We introduce function ${\sf ACFS}$ to read this value from world state $\st$

\begin{align}
	\mathsf{ACFS}(\st) &\eqdef \st[a_{\sf stake}]_{\bf s}[k_4]_v\\
	\mbox{where:} & \\
	a_{\sf stake} &\eqdef \stakingcontract \\ 
	k_4 &\eqdef {\sf [total\char`_storage\char`_tokens]_{\sf ch}} 
\end{align}

\subsection{Storage writing}\label{sec:storage_maintain}

In order to refund the storage collateral to payer when the storage entry is released, Conflux must track the owner for each storage entry. Here we formally describe the storage writing function $\Phi(\st,a,k,v,o)$, which sets storage entry $k$ of account $a$ to value $v$ and address $o$ is the storage owner. It returns updated world-state $\st'$. 

\begin{align}
	\st'   &\eqdef \st \qquad \mbox{  except:}\\ 
	\st'[a]_{\bf s}[k] &\eqdef\left\{
		\begin{array}{ll}
			(v,o) & v\neq 0\\
			\varnothing & v= 0\\
		\end{array}
	\right.\\
	\st'[s_o]_o &\eqdef \st[s_o]_o - 64 \times \collateralperbyte \quad \mbox{ if } v\neq \st[a]_{\bf s}[k]_v \;\wedge\; s_o\neq s'_o \;\wedge\; s_o\neq\varnothing \\ 
	\st'[s'_o]_o &\eqdef \st[s'_o]_o + 64 \times \collateralperbyte \quad \mbox{ if }v\neq \st[a]_{\bf s}[k]_v \;\wedge\; s_o\neq s'_o \;\wedge\; s'_o\neq\varnothing \\ 
	\text{where:} & \\
	s &\eqdef \st[a]_{\bf s}[k] \\
	s' &\eqdef \st'[a]_{\bf s}[k] 
\end{align}

There are five special storage entries in staking vote contract $\stakingcontract$, which record the statistic information about Conflux blockchain. Their owners are always the staking vote contract and they are exempted from storage collateral. Their keys are list as follows 
\begin{align}
	& \sf [accumulate\char`_interest\char`_rate]_{\sf ch} \\ 
	& \sf [interest\char`_rate]_{\sf ch} \\
    & \sf [total\char`_staking\char`_tokens]_{\sf ch} \\
    & \sf [total\char`_storage\char`_tokens]_{\sf ch} \\
    & \sf [total\char`_issued\char`_tokens]_{\sf ch} 
\end{align}

These five storage entries can only be accessed by the internal contract. In this document, we don't use function $\Phi$ when dealing with these entries and thus function $\Phi$ does not need to consider this special case. 
