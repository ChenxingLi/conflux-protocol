% !TEX root = ./tech-specification.tex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Blockchain Execution}

After determining the total order of blocks, the transactions are executed as if they are packed into sequential blocks on an Ethereum-like chain. 

Blockchain execution is based on a series of ordered blocks $\mathbf{L}$ and a subsequence of pivot blocks $\mathbf{P}$ output by figure~\ref{fig:order}. 
%
The pivot blocks divided into $\mathbf{L}$ into several epochs.  For $k\ge 1$, the epoch $k$ (denoted by $\mathbf{E}_k$) refers the slice in $\mathbf{L}$ started with the next block of $\mathbf{P}[k-1]$ and ended at block $\mathbf{P}[k]$. The epoch 0 refers the genesis block. 


\subsection{Initial state}

The initialization world state $\st^0$ is set as follows. A list $\vec{a}$ with elements $(a,b)$ gives the addresses $a$ and their balance $b$ when the \name blockchain launched.  
\begin{align}
	\forall (a,b)\in \vec{a}, \st^0[a]= \account^0 \quad \mbox{except:} \account_b=b 
\end{align}

In Oceanus, this list contains the following two addresses for faucet. Each address has initialization balance $5\times 10^{33}$ \unit, i.e., 5000 trillion \coinsign.
%
\begin{align*}
	\mathsf{0x1be45681ac6c53d5a40475f7526bac1fe7590fb8} \\
	\mathsf{0x1e768d12395c8abfdedf7b1aeb0dd1d27d5e2a7f}
\end{align*}

The \name internal contracts are also initialized.
%
\begin{align}
	\forall a\in \{a_{\sf stake},a_{\sf sponsor},a_{\sf admin}\}, \st^0[a] &\eqdef \account^0 \quad \mbox{except:} \account_n=1 \\
	\mbox{where:}&\\
	a_{\sf admin} &\eqdef \admincontract \\ 
	a_{\sf sponsor} &\eqdef \sponsorcontract \\
	a_{\sf stake} &\eqdef \stakingcontract
\end{align}

Besides, the global statistic information will be set as follows:

\begin{align}
	\st^0[a_{\sf stake}][k_1]_v & \eqdef \blockinyear\times 2^{80} \\ 
	\st^0[a_{\sf stake}][k_2]_v & \eqdef \blockinyear\times 40000 \\
	\st^0[a_{\sf stake}][k_3]_v & \eqdef 0 \\
	\st^0[a_{\sf stake}][k_4]_v & \eqdef 0 \\
	\st^0[a_{\sf stake}][k_5]_v & \eqdef \sum\nolimits_{(a,b)\in \vec{a}} b \\
	\mbox{where:}&\\
	a_{\sf stake} &\eqdef \stakingcontract \\
	k_1 &\eqdef \sf [accumulate\char`_interest\char`_rate]_{\sf ch} \\ 
	k_2 &\eqdef \sf [interest\char`_rate]_{\sf ch} \\
    k_3 &\eqdef \sf [total\char`_staking\char`_tokens]_{\sf ch} \\
    k_4 &\eqdef \sf [total\char`_storage\char`_tokens]_{\sf ch} \\
    k_5 &\eqdef \sf [total\char`_issued\char`_tokens]_{\sf ch} 
\end{align}


\subsection{Epoch execution}

The blockchain is executed epoch by epoch started with epoch 1. Let $\st_{k-1}$ denote the world state after the execution of epoch $k-1$. The Conflux protocol updates world state from $\st_{k-1}$ to $\st_k$ as follows. Besides updating the world state, the protocol also generates a receipt list $\mathbf{R}_k$ for epoch execution. 

\paragraph{Blocks execution. } First, all the blocks in epoch are executed in sequence by block execution function $\transition_{\sf block}(\st,\block,\mathbf{L}[0..(\tau-1)])=(\st',\mathbf{R}')$, where $\block$ is the block to be executed, $\tau$ is the the index of block $\block$ in $\mathbf{L}$ and $\mathbf{R}'$ is the sequence of transaction receipts. After executing all the blocks, the resultant world-state $\st^*$ becomes the input of the next step and the concatenation of block receipts becomes epoch receipts $\mathbf{R}$. Function $\transition_{\sf block}(\st,\block,\vec{L})$ is defined in section~\ref{sec:block_exec}.

\paragraph{Distribute mining reward. } Since Conflux incentive mechanism puts off the mining reward distribution for $\minerfreeze$ epochs, after execution of epoch $k$, Conflux distribute the mining reward for blocks in $\mathbf{E}_{k-\minerfreeze}$. The computing of mining reward for blocks in epoch $k-\minerfreeze$ requires the following context information.
\begin{itemize}[nosep]
	\item The epoch block set $\mathbf{E}_{k-\minerfreeze}$
	\item The world-state before the execution of all the block $\block$ in $\mathbf{E}_{k-\minerfreeze}$, denoted by $\st(\block)$.
	\item The transaction receipts of all the block $\block$ in $\mathbf{E}_{k-\minerfreeze}$, denoted by $\mathbf{R}'(\block)$.
	\item The tree-graph structure for blocks in $\past(\mathbf{P}[k-\minerfreeze+\anticonecountepoch])$. 
\end{itemize}

Section~\ref{sec:incentive} describes how to compute the block reward $\reward(\block)$ with the context information. The mining reward will be distributed to the block author if the author is . The global parameter \emph{total issued tokens} is updated accordingly. Suppose $\st^*$ is the world state after blocks execution, it will be updated to $\st^{**}$ by
%
\begin{align}
	\st^{**}&\eqdef \st^* \qquad \mbox{except:} \\ 
	\forall a\in \B_{160} \mbox{ with }& \mathsf{Type}_a \in \{[0000]_2,[0001]_2,[1000]_2\} \\ 
	\st^{**}[a]_b&\eqdef \st^*[a]_b +\sum\nolimits_{\block \in \mathbf{E}_{k-\minerfreeze}} \mathbb{I}(\block_{\head_a}=a) \times \reward(\block) \\ 
	\st^{**}[a_{\sf stake}]_{\bf s}[k_3]&\eqdef \st^*[a_{\sf stake}]_{\bf s}[k_3] +\sum\nolimits_{\block \in \mathbf{E}_{k-\minerfreeze}} \left(\mathbb{I}(\mathsf{Type}_{\block_{\head_a}} \in \{[0000]_2,[0001]_2,[1000]_2\} ) \times \reward(\block)-\sum\nolimits_{R\in \mathbf{R}'(\block)}R_f\right) \\ 
	\mbox{where:}&  \\
	a_{\sf stake} &\eqdef \stakingcontract \\ 
	k_3  &\eqdef [{\sf total\char`_issued\char`_tokens}]_{\sf ch}
\end{align}

\paragraph{Recycle storage for killed account. }

Let $\st^{**}$ be the world state after distributing mining reward. \name finally releases the storage for killed account and refunds corresponding storage collaterals. The transaction receipt $R$ contains a field $R_{\bf l}$ record all the killed address during execution. Let $K$ collects all the killed contracts in the whole epoch, the world state $\st'$ after storage recycle is defined by 
%
\begin{align}
	\st'&\eqdef \st^{**} \qquad \mbox{except:}\\
	\forall a'\in K, \st'[a']&\eqdef\varnothing \\
	\st'[a_{\sf stake}]_{\bf s}[k_4] & \eqdef \st^{**}[a_{\sf stake}]_{\bf s}[k_4] - \sum\nolimits_{a\in \B_{160}}f(a) \\
	\forall a \in \B_{160}
	 \mbox{ with }& {\sf Type}_a = [0001]_2, \\
	 \st'[a]_b& \eqdef\st^{**}[a]_b + f(a) \\ 
	 \st'[a]_o& \eqdef \st^{**}[a]_o - f(a)\\ 
	\forall a \in \B_{160}
	 \mbox{ with }&{\sf Type}_a = [1000]_2, \\ 
	 \st'[a]_p[{\sf col}]_b& \eqdef\st^{**}[a]_p[{\sf col}]_b + f(a) \\
	 \st'[a]_o& \eqdef \st^{**}[a]_o - f(a)\\
	\mbox{where:}  \\
	a_{\sf stake} & \eqdef \stakingcontract \\ 
	k_4 & \eqdef {\sf [total\char`_storage\char`_tokens]_{\sf ch}} \\ 
	f(a) &\eqdef \left\{\begin{array}{ll}
		\sum_{a'\in K}\sum_{k\in \B^*} \mathbb{I}[\st^{**}[a']_{\bf s}[k]_o=a]\times 64 \times \collateralperbyte & {\sf Type}_a \in \{[0001]_2, [1000]_2\} \\ 
		0 & \mbox{otherwise}
	\end{array}\right.
\end{align}

\subsection{Block execution}\label{sec:block_exec}
The block execution function $\transition_{\sf block}(\st,\block,\vec{L})$ consists of two steps. 

\paragraph{Update accumulate interest}
\begin{align}
	\st^{*}&\eqdef \st \qquad \mbox{except:} \\ 
	\st^{*}[a_{\sf stake}]_{\bf s}[k_1] & \eqdef \left\lfloor\st[a_{\sf stake}]_{\bf s}[k_1] \times \left(1+\frac{4\%}{\blockinyear}\right)\right\rfloor\\
	\mbox{where:}& \\ 
	a_{\sf stake} & \eqdef \stakingcontract \\ 
	k_1 & \eqdef [{\sf accumulate\char`_interest\char`_rate}]_{\sf ch}
\end{align}

\paragraph{Execute transactions in block}

Each block $\block$ contains a series of transactions $\block_{\sf Ts}$. Start with world state $\st^{*}$, \name executes these transactions in sequence by a transform function $\Upsilon(\st,\tx,\vec{L})=(\st',R)$, which updates world state from $\st$ to $\st'$ by processing transaction $\tx$ and outputs a receipt $R$. The input $\vec{L}$ represents the blocks in front of the present block.After executing all the transaction, the resultant state $\st'$ and the concatenation of all the transaction receipts $\mathbf{R}'$ consists of the output of function $\transition_{\sf block}$.

\section{Transaction Processing}
\label{sec:tx_processing}

\name implements the same virtual machine as Ethereum \cite{ETH_yellow}. 
The execution of a transaction defines the transform function $\Upsilon(\st,\tx,\tau)$, which is similar with Ethereum's state transition function.
In what follows we focus on the \name specific designs in the execution.

\subsection{Gas, Payment and Collateral}
\label{subsec:gas_and_pay}

As defined in Section~\ref{sec:tx} every transaction $\tx$ has two fields of {\bf gasLimit} and {\bf gasPrice} that declare the specific amount of associated gas $\tx_g$ and the price $\tx_p$ of per unit gas.
When starting the execution of a transaction $\tx$, the purchase of gas happens at the price $\tx_g \times \tx_p$ and the transaction $\tx$ is considered invalid if the actor responsible for the cost of gas consumption cannot afford such a purchase.
% , i.e. $\sender{\tx}_b < \tx_g \times \tx_p$.
\newversion{
	Normally $\sender{\tx}$, the sender of $\tx$, is responsible for the cost of gas consumption. 
	In case the transaction $\tx$ is calling a smart contract $\contract$ with sponsorship for gas consumption and $\tx$ is qualified for the subsidy as specified in Section~\ref{sec:sponsor}, 
	$\contract$ is responsible for the purchase of gas if it has sufficient \textbf{sponsor balance for gas},
	and otherwise the sender $\sender{\tx}$ is still responsible for the whole purchase of gas as if there were no sponsor at all.
}
Like in Ethereum, gas does not exist outside the execution of transactions.


	The unused gas can be refunded after the transaction $\tx$ is executed, but no more than a quarter of the total value spent on purchasing. 
	Thus, the \emph{refundable amount of gas} $g^{\dagger}$ is the minimum of the \emph{legitimately remaining gas} $g'$ and a quarter of the \textbf{gasLimit} of $\tx$,
	i.e. $g^{\dagger}\eqdef \min\set{g', \tx_g/4}$, 
	where in principle no gas is refundable (i.e. $g^{\dagger} = g' = 0$) if the execution of $\tx$ fails due to the sender's fault. 
	% The \emph{consumed amount of gas}\footnote{Here for simplicity we write $\gused(\cdot)$ as a function of $\tx$. However it is indeed a function defined on both $\tx$ and the world-state at the beginning of the execution of $\tx$. Thus, multiple occurrences of $\tx$ are considered as distinct inputs for this function and they may incur different amount of consumed gas.} $\gused(\tx)$ is defined as
	% \begin{align*}
	% 	\gused(\tx) \eqdef \begin{cases}
	% 		\tx_g-g^{\dagger} & \mbox{if $\tx$ is executed}\\
	% 		0 & \mbox{if $\tx$ is not executed (i.e. only when $R_z=2$ as in Section~\ref{sec:tx validate})}
	% 	\end{cases} 
	% \end{align*}
	The actor who initially purchased the gas for $\tx$ will get the refund of $g^{\dagger}\times\tx_p$. And the \coinsign paid for the consumed gas is 
	%
	\begin{align}
		\left(\tx_g-g^{\dagger}\right)\times \tx_p.
	\end{align}
	%
	If the $\tx$ is not executed (i.e. only when $R_z=2$ as in Section~\ref{sec:tx validate})), no gas will be charged. If the sender $\sender{\tx}$ can not afford gas fee, all its the remained balance of sender $\sender{\tx}$ will be charged as gas fee. The actual charged gas fee will be record in receipt $R_f$. 

	
The charged gas fee is added to the reward pool for miners. Thus in general a higher gas price on a transaction would cost the sender more but also increase the chance of being processed timely.

In computing the accumulated gas used of the whole block, the non-refundable gas $g^{\dagger} - g'$ is not taken into consideration. But in case the sender $\sender{\tx}$ can not afford gas fee, the gas used is considered as $\tx_g$, even if the actual charged gas fee is less than $\tx_p\times\tx_g$. The gas used is also recorded in receipt $R_g$. 
%
Thus the accumulated gas used of a block is intrinsically taking the summation of field $R_g$ over transaction receipts.

Every transactions also have a filed of \textbf{storage limit} that declare the maximum storage bytes $\tx_\ell$ increasing for the present transaction. Before transaction execution, besides gas fee and transferred value, the sender $\sender{\tx}$ must have enough balance for storage collateral for specified storage limit, i.e., $\tx_\ell\times\collateralperbyte\;\unit$. Unlike the gas fee, these collateral will not be charged or locked at this time. At the end of transaction execution, if the sender doesn't have enough balance paying for the increased storage collateral or the increased storage bytes of sender exceeds storage limit, the transaction execution fails. More details for collateral for storage is specified in section~\ref{sec:collateral}. 

\subsection{Pre-execution Validation}
\label{sec:tx validate}

Before being executed, a transaction $\tx$ in the processing queue must pass the following secondary test of intrinsic validity. 
\begin{enumerate}[nosep]
	\item The current epoch is in the range specified by \textbf{epochHeight}, 
	i.e. current epoch height is in $[\tx_e - \txepochbound, \tx_e + \txepochbound]$.
	
	\item The transaction \textbf{nonce} is valid,
   i.e. $\tx_n = \st\left[\sender{\tx}\right]_n$ where $\st$ is the current world-state.

   \item The recipient address is valid , i.e. the type indicator (first $4$-bit) of $\tx_a$ belongs to $\set{\typereserved,\typenormal,\typecontract}$.
\end{enumerate}

Note that the local legality of the transaction, 
e.g. the $\rlp$ format
% , intrinsic gas limit, 
and the validity of signature, 
is already verified in the first intrinsic validity test before accepting the corresponding block into the \name \tg, as discussed in Section~\ref{sec:block validate},
and will not be checked again at this moment.

If $\tx$ fails at these checks, the transaction will not be executed, the nonce for account will not increase and no transaction fee is charged for such transaction. Let $R'$ be the receipt of last transaction.
Then the receipt of current transaction will be set as follows:
\begin{align}
	R_u=R'_u && R_f=0 && R_g=0 && R_{\bf l}=\emptystring && R_z=2 && R_s=0 && R_{\bf o}=\emptystring && R_{\bf i}=\emptystring
\end{align}
%
(The bloom filter $R_b$ of log $R_{\bf l}$ is computed accordingly. 
)


If $\tx$ passes all the above pre-execution checks, the execution of $\tx$ is as specified in the rest of this section.

\subsection{Transaction Execution}

\subsubsection{Eligibility for sponsorship}

When $\tx$ is calling a contract $\contract$, the gas fee and storage collateral during the transaction execution could be sponsored by the contract $\contract$. If the sender $\sender{\tx}$ is in the {\bf sponsor whitelist} of contract $\contract$, the gas fee of the current transaction does not exceed the {\bf sponsor limit for gas} of contract and contract $\contract$ has a {\bf sponsor for gas}, transaction $\tx$ is eligible for sponsorship on gas consumption. Formally, we define 
\begin{align}
	\mathsf{GasElig}(\st,\tx)\eqdef \quad \mathrm{Type}_{\tx_a}=\typecontract \;\wedge\; \mathsf{Whitelist}(\st,\sender{\tx},\contract) \;\wedge\; \st[\tx_a]_p[\mathsf{gas}]_a\neq 0 \;\wedge\; \tx_g\times\tx_p \le \st[\tx_a]_p[\mathsf{limit}] 
\end{align}
where function $\mathsf{Whitelist}(\cdot)$ is defined in \cref{eq:whitelist}. 

If the sender $\sender{\tx}$ is in the {\bf sponsor whitelist} of contract $\contract$ and contract $\contract$ has a {\bf sponsor for collateral}, transaction $\tx$ is also eligible for sponsorship on storage collateral.
\begin{align}
	\mathsf{ColElig}(\st,\tx)\eqdef \quad \mathrm{Type}_{\tx_a}=\typecontract \;\wedge\; \mathsf{Whitelist}(\st,\sender{\tx},\contract) \;\wedge\; \st[\tx_a]_p[\mathsf{col}]_a\neq 0
\end{align}

\subsubsection{Preprocessing}
\label{subsubsec:preprocessing}

In the preprocessing phase of $\tx$, the balance of $\sender{\tx}$ (and the sponsor, if applicable) is examined so that the payment for any further operation is assured.
The world-state will be transformed from $\st$ into $\st^0\eqdef \st^{**}$ if $\tx$ passes the preprocessing, or directly into $\st'$ and the execution is aborted if $\tx$ fails at any step.

\paragraph{Nonce incremental.}
The beginning of execution 
causes an irrevocable changed to the state $\st$: 
the nonce of the sender, $\sender{\tx}_n$, is incremented by one. 
%
We define the state $\st^*$:
\begin{align}
	\st^*  &\eqdef \st \qquad \mbox{  except:}\\
	\st^*\left[\sender{\tx} \right]_n &\eqdef \st\left[\sender{\tx} \right]_n+1 
\end{align}

\paragraph{Gas consumption payment validation.}

The up-front payment of a transaction $\tx$ first figures out whether the gas consumption is sponsored. $\tx$ is sponsored on gas consumption if $\tx$ is eligible for sponsorship on gas consumption and the calling contract has sufficient \textbf{sponsor balance for gas fee}. 
\begin{align}
	\mathsf{GasSpr}(\st,\tx) \eqdef\quad  \mathsf{GasElig}(\st,\tx) \;\wedge\; \st[\tx_a]_p[{\sf gas}]_b\ge \tx_g\times\tx_p
\end{align}
\begin{itemize}
	\item If the gas consumption of $\tx$ is sponsored, the world-state $\st^{**}$ after gas consumption payment is as follows: 
	\begin{align}
		\st^{**}  &\eqdef \st^* \qquad \mbox{  except:}\\
		\st^{**}\left[\contract_{addr}\right]_p[{\sf gas}]_b &\eqdef \st^*\left[I_a\right]_p[{\sf gas}]_b-\tx_g\times\tx_p
	\end{align} 
	
	\item Otherwise, the sender $\sender{\tx}$ is required to pay for the gas consumption. 
	The balance of $\sender{\tx}$ should satisfy $\st^{*} \left[\sender{\tx}\right]_b \ge \tx_g\times\tx_p+\tx_v$ and otherwise a \emph{not enough balance exception} is generated. The handling of \emph{not enough balance exception} will be discussed later.
	The world-state after the gas consumption payment is defined as: 
	\begin{align}
		\st^{**}  &\eqdef \st^* \qquad \mbox{  except:}\\
		\st^{**} \left[\sender{\tx}\right]_b &\eqdef \max\set{\st^*\left[\sender{\tx}\right]_b-\tx_g\times\tx_p,0}
	\end{align}
\end{itemize}

\paragraph{Storage limit validation.}

After charging, Conflux decides who is responsible for storage collateral. If $\tx$ is eligible for sponsorship on storage collateral and calling contract $\contract=\tx_a$ has enough \textbf{sponsor balance for collateral}, contract $\contract$ is responsible for the storage collateral resulted in the execution of $\tx$ and will be the owner of modified entries. 
%
Otherwise, the sender $\sender{\tx}$ is the owner of modified entries
and has the obligation to pay corresponding storage collateral. 
%
\begin{align}
	\mathsf{ColSpr}(\st,\tx) &\eqdef\quad  \mathsf{ColElig}(\st,\tx) \;\wedge\; \st[\tx_a]_p[{\sf col}]_b\ge \tx_\ell\times 10^{18}/1024 \\
	\mathsf{ColOwner}(\st,\tx) &\eqdef\left\{ \begin{array}{ll}
		\tx_a & \text{if } \mathsf{ColSpr}(\st,\tx) = \true \\ 
		\sender{\tx} & \text{if } \mathsf{ColSpr}(\st,\tx) = \false \\ 
	\end{array}\right.
\end{align}

If $\sender{\tx}$ is the storage owner but his balance cannot afford the full collateral as declared in {\bf storageLimit} after transferring value $\tx_v$, 
i.e. $\st^{**}[\sender{\tx}]_b<\tx_v+\tx_\ell\times 10^{18}/1024$, 
then the execution of $\tx$ fails due to \emph{not enough balance exception}. 

\paragraph{Handling not enough balance exception.} 

Whenever the preprocessing of $\tx$ generates a \emph{not enough balance exception} during preprocessing, the execution of $\tx$ fails and there will be no further execution of $\tx$. To figure out whether this exception caused by the insufficient sponsorship balance in contract, the sender balance before transaction execution (i.e. $\st[\sender{\tx}]_b$) is compared with a \emph{minimum required balance} defined as
\begin{align}
	\tx_v+(1-\mathbb{I}(\mathsf{GasElig}(\st,\tx)))\times \tx_g \times \tx_p + (1-\mathbb{I}(\mathsf{ColElig}(\st,\tx)))\times \tx_\ell \times \collateralperbyte.
\end{align}

If $\st[\sender{\tx}]_b$ has enough balance for \emph{minimum required balance}, the sender $\sender{\tx}$ is considered not responsible for the generated \emph{not enough balance exception}. 
In this case, the resultant world-state $\st'$ is reverted to $\st$, the nonce of sender is reset so that $\tx$ is reusable. The receipt is composed as follows (where $R'$ refers the receipt of last transaction):
\begin{align}
	&R_u=R'_u && R_f=0 && R_g=0 && R_{\bf l}=\emptystring \\
	&R_z=2 && R_s=0 && R_{\bf o}=\emptystring && R_{\bf i}=\emptystring
\end{align}

In other cases, sender $\sender{\tx}$ is responsible for the exception. The resultant world-state is $\st'\eqdef \st^{**}$ and the receipt is composed as follows (where $R'$ refers the receipt of last transaction):
\begin{align}
	&R_u=R'_u+\tx_g && R_f=\min\{\tx_g\times\tx_p,\st[\sender{\tx}]_b\} && R_g=\mathsf{GasElig}(\st,\tx) && R_{\bf l}=\emptystring \\
	&R_z=1 && R_s=0 && R_{\bf o}=\emptystring && R_{\bf i}=\emptystring
\end{align}


\subsubsection{Execution Substate}
\label{subsubsec:substate}

The \emph{transaction substate} $A$ is a five tuple which accrues intermediate information during execution. 
\begin{align}
	A\eqdef \left( A_{\bf s}, A_{\bf l}, A_{\bf t}\right)
\end{align}
The components of $A$ are defined as follows: 
\begin{itemize}[nosep]
	\item $A_{\bf s}$ is the self-destruct set of accounts that will be discarded upon the transaction's completion.

	\item $A_{\bf l}$ is the log series consisting of indexable ``checkpoints'' in the VM code execution, allowing light clients to track the execution of a contract.

	\item $A_{\bf t}$ is the set of touched accounts, of which the empty ones will be deleted on the transaction's completion.
\end{itemize}

The empty substate $A^0$, which is also the initial substate, has no self-destructs, no logs, no touched accounts, and zero refund. Formally, $A^0$ is defined as
\begin{align}
	A^0\eqdef \left( \varnothing, \emptystring, \varnothing\right)
\end{align}

For any two substate $A^1$ and $A^2$, the accrued substate $A\eqdef A^1\Cup A^2$ is defined by 
\begin{align}
	A_{\bf s} &\eqdef A^1_{\bf s} \cup A^2_{\bf s} \\ 
	A_{\bf l} &\eqdef A^1_{\bf l} \cdot A^2_{\bf l} \\
	A_{\bf t} &\eqdef A^1_{\bf t} \cup A^2_{\bf t} 
\end{align}


\subsubsection{Type dependent execution}

If transaction passes the preprocessing, 
then {\name} evaluates the \emph{post-execution provisional state} $\st^P$ from \emph{pre-execution provisional state} $\st^0$ depending on the transaction type as specified in $\tx_a$: either contract creation or message call. 
%
The gas available for the proceeding computation is $g\eqdef \tx_g-g_0$, where $g_0$ is the intrinsic cost of $\tx$ as in (\ref{def:g0}). 

We define the tuple of post-execution provisional state $\st^{P}$, remaining gas $g'$, accrued substate $A$ and status code $z$:
\begin{align}\label{def:transform}
	(\st^{P},g',A,z)\eqdef
	\begin{cases}
		\creation(\st^0,\sender{\tx},\sender{\tx},\emptystring, \mathsf{ColOwner}(\st,\tx),g,\tx_p,\tx_v,\tx_{\bf i},0,\top) &  \tx_a=\varnothing \\
		\execution(\st^0,\sender{\tx},\sender{\tx},\tx_a,\emptystring,\mathsf{ColOwner}(\st,\tx),\tx_a,g,\tx_p,\tx_v,\tx_v,\tx_{\bf d},0,\top) & \tx_a\neq\varnothing
	\end{cases}
\end{align}
%
Notice that we have three more parameters compared with Ethereum. 

The specifications of function $\creation$ and $\execution$ are given in Section~\ref{sec:creation} and Section~\ref{sec:execution} respectively.

\subsubsection{Postprocessing}\label{sec:tx_post_process}

\paragraph{Storage collateral refund and charge.}

After the message call or contract creation is processed, Conflux checks whether the incremental storage exceeds storage limit specified in $\tx_\ell$ and if the storage owner has enough balance for storage collateral. 
Let $i\eqdef \mathsf{ColOwner}(\st,\tx)$ be the address who owns modified storage entries and $v$ be the available balance to pay for storage collateral, which is defined as 
\begin{align}
	v \eqdef \begin{cases}
		\st^{P}[\sender{\tx}]_b & \text{if }\mathsf{ColSpr}(\st,\tx)=\false \\
		\st^{P}[\tx_a]_p[{\sf col}]_b &  \text{if }\mathsf{ColSpr}(\st,\tx)=\true
	\end{cases}
\end{align}
%
Notice that $\st^P[i]_o-\st^0[i]_o$ is the incremental storage collateral during execution.
If $\st^P[i]_o-\st^0[i]_o>\min\{v,\tx_\ell\times 10^{18}/1024\}$, then the execution fails because of exceeding the storage limit, 
and all the modified state will be reverted to $\st^0$, 
i.e. $\st'\eqdef\st^0$. 
Let $R'$ denote the receipt of last transaction.
Then the receipt of current transaction $\tx$ will be 
\begin{align}
	&R_u=R'_u+\tx_g && R_f = \tx_g\times\tx_p && R_g = \mathsf{GasSpr}(\st,\tx) && R_{\bf l}=\emptystring \\
	&R_z=1 && R_s = \mathsf{ColSpr}(\st,\tx) && R_{\bf o}=\emptystring && R_{\bf i}=\emptystring
\end{align}

Otherwise \name charges and refunds storage collateral and transforms world-state $\st^P$ into $\st^*$. 
We skim the self-destructed contracts here because their storage collateral have been refunded during self-destruction. 
The storage collateral in account state is also updated at this time. 

\begin{align}
	&\st^1  \eqdef \st^{P} \qquad \mbox{  except:}\\
	&\forall a \in \B_{160} \text{ with } \st^{P}[a]_o\neq\st^0[a]_o, \\
	&\quad \begin{cases}
	\st^1[a]_p[{\sf col}]_b \eqdef \st^{P}[a]_p[{\sf col}]_b - (\st^{P}[a]_o-\st^0[a]_o) & \mbox{if $a$ refers to a contract account, i.e. $\mathsf{Type}_{a}=\typecontract$} \\
	\st^1[a]_b \eqdef \st^{P}[a]_b - (\st^{P}[a]_o-\st^0[a]_o) & \mbox{if $a$ refers to a normal account, i.e. $\mathsf{Type}_{a}= \typenormal$}
	\end{cases}\\
	&\st^1[a_{\sf stake}]_{\bf s}[k_4] \eqdef \st^P[a_{\sf stake}]_{\bf s}[k_4] + \sum_{a\in \B_{160}}(\st^{P}[a]_o-\st^0[a]_o) \\
	&\mbox{where:}  \\
	&a_{\sf stake} \eqdef \stakingcontract \\ 
	&k_4 \eqdef {\sf [total\char`_storage\char`_tokens]_{\sf ch}} 
\end{align}

\paragraph{Sponsor balance for collateral refund.}

After refunding collateral for storage, the sponsor balance for collateral of all the destructed contract are refunded to their sponsor.

\begin{align}
	&\st^2  \eqdef \st^1 \qquad \mbox{  except:}\\
	&\forall a \in \B_{160},\;  \st^2[a]_b\eqdef \st^1[a]_b + \sum_{a'\in A_{\bf s}} \mathbb{I}(\st^1[a']_p[{\sf col}]_a=a)\times \st^1[a']_p[{\sf col}]_b \\
	&\forall a' \in A_{\bf s},\; \st^2[a']_p[{\sf col}]_b\eqdef 0
\end{align}


\paragraph{Gas fee refund.}

The \emph{refundable amount of gas} $g^{\dagger}$ is the minimum of the \emph{legitimately remaining gas} $g'$ (as calculated in (\ref{def:transform})) and a quarter of the \textbf{gasLimit} of $\tx$,
	i.e. $g^{\dagger}\eqdef \min\set{g', \tx_g/4}$.
The refund of gas fee is applied on world-state $\st^{*}$ and results in $\st'\eqdef \Upsilon(\st,\tx)$.

\begin{align}
	& \st'  \eqdef \st^2 \qquad \mbox{  except:}\\
	& \quad \begin{cases} 
		\st'\left[\tx_a\right]_p[{\sf gas}]_b \eqdef \st^2\left[\tx_a\right]_p[{\sf gas}]_b+g^{\dagger}\times \tx_p 
		& \mbox{if $\mathsf{GasSpr}(\st,\tx)=\true$}\\
		\st' \left[\sender{\tx}\right]_b \eqdef \st^2\left[\sender{\tx}\right]_b + g^{\dagger}\times \tx_p 
		& \mbox{if $\mathsf{GasSpr}(\st,\tx)=\false$}
	\end{cases} 
\end{align}

\paragraph{Transaction Receipt.} 

Now the transaction execution is accomplished.
The returning status code $z$ denotes whether the execution succeeds or not. 
Supposing that $R'$ is the receipt of last transaction, 
the receipt of current transaction will be as follows:
\begin{align}
	\begin{array}{llll}
		R_u=R'_u+g' & R_f = (\tx_g-g^{\dagger})\times \tx_p & R_g = \mathsf{GasSpr}(\st,\tx) & R_{\bf l}=A_{\bf l} \\ 
		R_z=z & \multicolumn{3}{l}{R_s = \left\{\begin{array}{ll}
			\mathsf{ColSpr}(\st,\tx) & \text{if }z=0\\
			0 & \text{if }z=1
		\end{array}\right.} \\
		\multicolumn{4}{l}{R_{\bf o}=\mathsf{ToList}\left(\left\{ (a,\st^P[a]_o - \st^0[a]_o) | a\in \B_{160}\;\wedge\; \st^P[a]_o - \st^0[a]_o>0 \right\}\right)}\\
		\multicolumn{4}{l}{R_{\bf i}=\mathsf{ToList}\left(\left\{(a,\st^0[a]_o - \st^P[a]_o) | a\in \B_{160}\;\wedge\; \st^P[a]_o - \st^0[a]_o<0  \right\}\right)}
	\end{array}
\end{align}


\subsection{Contract Creation}
\label{sec:creation}

A number of intrinsic parameters are used when creating a smart contract account:
\begin{itemize}[nosep]
	\item world-state ${\st}$;
	
	\item sender $s$;

	\item original sender $o$;
	
	\item other recipients in call stack $\vec{t}$;
	
	\item storage owner $i$;
		
	\item available gas $g$;

	% \item storage limit $\ell$;

	\item gas price $p$;

	\item endowment $v$;

	\item initialization code $\vec{i}$ as an arbitrary length byte array;

	\item the present depth of message-call/contraction-creation stack $e$;

	\item the salt for new account's address $\zeta$,\\
	where $\zeta = \varnothing$ if the creation was caused by {\hyperlink{create}{$\op{CREATE}$}}, 
	and $\zeta\in \B_{256}$ if the creation was caused by {\hyperlink{create2}{$\op{CREATE2}$}};

	\item and finally the permission to change the state $w$.
\end{itemize}


We define the contract creation function by $\creation$,
which evaluates from the above parameters and modifies the state $\st$ to a new state $\st'$, together with the leftover gas $g'$, the accrued substate $A$, the result of creation, and the output $\vec{o}$. 
\begin{align}
	\left(\st',g', A, z, \vec{o} \right)\eqdef \creation\left(\st, s, o, \vec{t},i, g, p, v, \vec{i}, e, w \right)
\end{align}


The address $a$ of the account $\account$ newly created by {\hyperlink{create}{$\op{CREATE}$}} is defined as the $4$-bit contract type indicator concatenating the rightmost $156$ bits (i.e. the $100$-th to $255$-th bit) of the Keccak hash of a zero byte, the sender address $s$, the little-endian 32-byte array of its account nonce and the Keccak hash of \cvm code. 
% 
For {\hyperlink{create2}{$\op{CREATE2}$}} the rule is slightly different by substituting account nonce with the salt $\zeta$ and changing the leading byte before taking Keccak (following EIP-1014).
Combining these two cases, 
the resultant address for the new contract account $\account$ is defined as follows:
\begin{align}\label{eq:new-address}
	a= A(s, \st[s]_{n} - 1, \zeta, \vec{i}) \eqdef 
	\left\{\begin{array}{l l l l l}
	 	\typecontract \circ \kec\big([\mathrm{00}]_{16} &~\circ~ s &\circ~ \mathrm{LE}_{32}(\st[s]_n-1) &\circ~ \kec(\vec{i}) \big)[100 \dots 255]
	 	& \text{if}\ \zeta = \varnothing \\
	 	\typecontract \circ \kec\big([\mathrm{ff}]_{16} &~\circ~ s &\circ~  \zeta   &\circ~ \kec(\vec{i}) \big)[100 \dots 255] 
		& \text{otherwise}
	\end{array} \right.
\end{align}
where $\mathrm{LE}_{32}(\cdot)$ denotes the function that expands an integer value in $[0,2^{256}-1]$ to a little-endian 32-byte array. 
%
Note that we use $\st[s]_n-1$ since it is indeed the sender's nonce at the generation of the respective transaction or VM operation. 

If $\st[a]_c\neq \kec(\emptystring)$, a \emph{Contract Address Conflict} exception is triggered. Function $\creation$ returns $(\varnothing,g,A^0,1)$ immediately. 

Otherwise, the account's nonce is initialized to one, the balance as the value passed by the contract creation transaction,
the storage and code as for the empty string.
The sender's balance is reduced by the transferred value (there must be enough balance or the transaction will not be executed).
Thus the mutated state becomes $\st^*$:
\begin{align}
	\st^* & \eqdef \st \qquad{ \text{except:}}\\
	\st^*[a] &\eqdef \account^0 \quad\text{except:}\; \st^*[a]_n=1 \wedge \st^*[a]_b=v+\st[a]_b \wedge \st^*[a]_a=s\\
	% \left(a, \account_{state}\right)\\
	\st^*[s] &\eqdef \begin{cases}
		\varnothing & \mbox{if $\st[s]=\varnothing$ $\land$ $v=0$}\\
		\st[s]\quad\mbox{except}:	\st^*[s]_b=\st[s]_b-v	& \mbox{otherwise}
	\end{cases}
\end{align}
where $\account^0$ is the default account specified in~\cref{eq:default_account}. 

The unmentioned components of an account are initialized by default.

Finally the account $\account$ is initialized by \cvm code $\vec{i}$ according to the execution model.
Code execution may effect several events that are not internal to the execution state:
the account's storage can be altered, further accounts can be created and further messages calls can be made.
As such, the code execution function $\execute$ evaluates to a tuple of resultant state $\st^{**}$, available gas remaining $g^{**}$, the accrued substate $A$ and the body code $\vec{o}$.
\begin{align}
	\left(\st^{**}, g^{**},  A, \vec{o} \right) \eqdef \execute\left(\st^*, g, I\right)
\end{align}
where $I$ consists of the parameters of the execution environment as follows:
\begin{align}
	I_a &\eqdef a\\
	I_o &\eqdef o\\
	I_i &\eqdef i\\
	I_p &\eqdef p\\
	I_\vec{d} &\eqdef \emptystring\\
	I_\vec{t} & \eqdef \vec{t}\\
	I_s &\eqdef s\\
	I_v &\eqdef v\\
	I_\vec{b} &\eqdef \vec{i}\\
	I_{\head} & \eqdef \head \\
	I_\vec{L} & \eqdef \vec{L} \\ 
	I_e &\eqdef e\\
	I_w &\eqdef w
\end{align}

$I_{\vec{d}}$ evaluates to the empty tuple as there is no input data to this call. 
$I_{\head}$ is the block header of the present block.
$I_\vec{L}$ is the list of block headers ordered in front of the current block.

Code execution depletes gas, and gas may not go below zero, thus the actual execution may exit before the code has come to a natural halting state.
In this (and several other) exceptional cases (i.e. $\st^{**}=\varnothing \land \vec{o}=\varnothing$), we say an out-of-gas (OOG) exception has occurred:
the evaluated state is set to the empty set $\varnothing$, 
and the entire contract creation should have no effect on the state, effectively leaving it as it was immediately prior to the attempt of the failed creation.
%
Function $\creation$ returns $(\varnothing,g^{**},A^0,1)$ immediately. 


If the initialization code completes successfully,
a final storage cost is charged for depositing the code.
The storage cost $s$ is proportional to the code size of the created contract and it consists of two parts:
\begin{itemize}
	\item the code-deposit cost $d$ charged as gas consumption:
	\begin{align}
		d \eqdef   |\vec{o}| \times G_{codedeposit}
	\end{align}

	\item a substate $A^{*}$ will be generated to record the storage occupied by code size. the code size collateral will be charged in transaction post processing and will be locked during the lifetime of the created contract. (Conflux will record the owner of code in world-state and refund the collateral when the contract is destroyed):
	\begin{align}
		A^{*} \eqdef   A^0 \quad\mbox{except: }A^*_{\bf c}[i]=|\vec{o}|
	\end{align}
\end{itemize}


If the remaining gas cannot afford the code-deposit cost (i.e. $g^{**}<d$) or the code size exceeds 49152 bytes (i.e. $|\vec{o}|<49152$), then we also declare that an exception occurs and handle it as a failed contract creation attempt. 
%
Function $\creation$ returns $(\varnothing,g^{**},A^0,1)$ immediately. 

If the contract creation fails for any reason, the value of the transaction is not transferred to the aborted contract, and collateral for storing the code is not locked either.
If the contract creation succeeds, we formally specify the resultant state, gas, storage limit, substate, and status code by $\left(\st', g', A', z\right)$ as follows:
\begin{align}
	g' &\eqdef g^{**}-d \\
	\st' &\eqdef \st^{**} \quad\mbox{except:} \\
		\st'[a]_c &\eqdef \kec(\vec{o}) \\ 
		\st'[a]_{code} &\eqdef (\vec{o},i) \\
		\st'[i]_{o}    &\eqdef \st^{**}[i]_{o}  + |\vec{o}|\times \collateralperbyte \\
	\notag \\
	A' &\eqdef A \Cup A^{*} \\ 
	z &\eqdef 0
\end{align}

In the determination of $\st'$, the final body code for the newly created account is specified by the byte sequence $\vec{o}$ derived from the execution of the initialization code $\vec{i}$.
The status code $z$ is an indicator of whether the contract creation succeeds.

Therefore the result of contract creation is either a successfully created new contract with its endowment and collateral for storage, or no new contract and no transfer of value or collateral at all.

\paragraph{Subtleties.} 
Note that while the initialization code is executing, the newly created address exists but with no intrinsic body code. 
Thus any message call received by it during this time causes no code to be executed. 
If the initialization execution ends with a $\op{SUICIDE}$ instruction, the matter is moot since the account will be deleted before the transaction is completed. 
For a normal $\op{STOP}$ code, or if the code returned is otherwise empty, then the world-state may left with a zombie account. Only the administrator of such contract can destroy it by calling the internal contract described in \cref{sec:admin}.



\subsection{Message Call}\label{sec:execution}
The following intrinsic parameters are used when executing a message call:
\begin{itemize}[nosep]
	\item world-state ${\st}$;
	
	\item sender $s$;

	\item original sender $o$;

	\item recipient $r$;
	
	\item other recipients in call stack ${\bf t}$
	
	\item storage owner $i$

	\item the account $c$ whose code is to be executed, usually the same as recipient; 

	\item available gas $g$;

	\item gas price $p$;

	\item value $v$;

	\item input data $\vec{d}$ of the call, as an arbitrary length byte array;

	\item the present depth of message-call/contraction-creation stack $e$;

	\item and finally the permission to change the state $w$.
\end{itemize}

During the execution of message calls, 
the state and transaction substate may change,
and finally an output data array $\vec{o}$ will be generated.
In case of executing transactions (generated by external controllers) the output data $\vec{o}$ is ignored, however message calls (generated by internal execution process) can result further consequences due to the execution of VM-codes, especially when the message call is generated inside the execution of another message call (or transaction).
\begin{align}
  	\left(\st', g', A, z, \vec{o} \right) \eqdef \execution\left(\st,s,o,r,\vec{t},i,c,g, p,v,\tilde{v},\vec{d},e,w \right)
\end{align}  
Note that we differentiate between the value to be transferred, $v$, from the value apparent in the execution context, $\tilde{v}$, for the $\op{DELEGATECALL}$ instruction.

We let $\st^*$ denote the first transitional world-state, which is the same as the original state except for the value transferred from sender $s$ to recipient $r$ (if $s\ne r$):
\begin{align}
	\st^*[r]_b\eqdef \st[r]_b+v \qquad \land  \qquad\st^*[s]_b\eqdef \st[s]_b-v
	\label{state:first transitional}
\end{align}

In particular, if $\st[r]$ was undefined in $\st$, \name will treat it as an empty account with address $r$ which has no code or state and zero balance and nonce.
If furthermore the transferred value $v$ is positive, the account will be created and stored in $\st^*[r]$. 
Thus the previous equation should be taken to mean:
\begin{align}
	\st^* &\eqdef \st \qquad \mbox{except:}\\
	\st^*\left[ s \right] &\eqdef \begin{cases}
		\varnothing & \mbox{if $\st[s]=\varnothing$ $\land$ $v=0$}\\
		\st[s]\quad\mbox{except:}\st^*[s]_b=\st[s]_b-v & \mbox{otherwise}
	\end{cases}\\
% \end{align}
% \begin{align}
	% \mbox{and}\qquad \st'_1 &\eqdef \st \qquad \mbox{except:}\\
	\st^*[r] &\eqdef \begin{cases}
		\account^0 \quad\text{except:}\; \st^*[r]_b=v  & \mbox{if $\st[r]=\varnothing \;\land\; v\ne 0$}\\
		\varnothing & \mbox{if $\st[r]=\varnothing \;\land\; v = 0$}\\
		\st[r]\quad\mbox{except:}\st^*[r]_b=\st[r]_b+v\; & \mbox{otherwise}
	\end{cases}
\end{align}

The recipient's associated code $\vec{b}$, whose Keccak hash is $\st[r]_c$, is executed according to the execution model if the re-entrance protection is not triggered as in Section~\ref{subsubsec:reentrance}.
Note that the pair $\left( \kec(\vec{b}), \vec{b} \right)$ must be stored at some previous point, i.e. at the last update of the code hash $\st[r]_c$ of the recipient's account. 
Thus $\vec{b}$ can be efficiently determined from $\st[r]_c$,
and it is unique following the collision resistance of $\kec$.

Similar as with contract creation, if the execution halts due to an exception, then the state is reverted to the point immediately prior to balance transfer (i.e. $\st$) of the message call but no gas is refunded.
The new state $\st'$ after executing this message call is as follows:
\begin{align}
	\st' &\eqdef 
	\begin{cases}
		\st 	 	& \mbox{if $\st^{**}=\varnothing$}\\
		\st^{**} 	& \mbox{otherwise}
	\end{cases}\\
	g' & \eqdef 
	\begin{cases}
		0 & \mbox{if $\st^{**} =\varnothing$ $\land$ $\vec{o}=\varnothing$}\\
		g^{**} & \mbox{otherwise}	
	\end{cases}\\
	z &\eqdef 
	\begin{cases}
		1	 	& \mbox{if $\st^{**}=\varnothing$}\\
		0	 	& \mbox{otherwise}
	\end{cases}
\end{align}
where the resultant state $\st^{**}$ and available gas remaining $g^{**}$, together with the accrued substate $A$ and the output data $\vec{o}$, 
are determined by the code execution function $\execute$ evaluated on state $\st^*$.
\begin{align}
	\left(\st^{**}, g^{**},  A, \vec{o} \right) \eqdef \execute \left(\st^*, g, I  \right)
\end{align}
where $I$ contains the parameters of the execution environment as follows:
\begin{align}
	I_a &\eqdef r\\
	I_o &\eqdef o\\
	I_i &\eqdef i\\
	I_p &\eqdef p\\
	I_\vec{d} &\eqdef \vec{d}\\
	I_\vec{t} &\eqdef \vec{t}\\
	I_s &\eqdef s\\
	I_v &\eqdef \tilde{v}\\
	I_\vec{b} &\eqdef \vec{b}\\
	I_{\head} & \eqdef \head \\
	I_{\mathbf{L}} & \eqdef \mathbf{L}\\ 
	I_e &\eqdef e\\
	I_w &\eqdef w	% I_\vec{b} \;\; &\text{such that }  \kec\left(I_\vec{b}\right)  = \st[r]_c
\end{align}




For the frequently used functionalities such as the elliptic curve public key recovery, the SHA2-$256$ hash scheme, and so on, we set up eight ``precompiled computation contracts'' with reserved code's address $c\in\set{1,2,\dots,8}$ (with type indicator $\typereserved$). The precompiled computation contracts have no side-effect during execution. They will not generate logs, modify accounts' storage or trigger another message call. 
%
In the present implementation of \name these exceptional contracts are specified as in the latest version of Ethereum \cite{ETH_yellow}.

\name also introduces internal contracts for specific usage. A high-level description for the internal contracts is given in Section~\ref{sec:internal}. When the recipient's address $r$ is one of the internal contracts, Conflux processes $\execute_{\sf internal}(\st^*,g,I)$ and returns $\left(\st^{**}, g^{**},  A, \vec{o} \right)$. A formal definition is given in section~\ref{sec:internal_contract}. 


\subsection{Execution Model}
\label{sec:exe model}

The execution model specifies the system state transition on input of a sequence of bytecode instructions and a small tuple of environmental data. 
The state transition function is formalized as a virtual state machine,
which 
% This virtual machine 
is Turing-complete except that its running time and storage space is intrinsically bounded by the limited amount of available gas and collateral for storage.
% 
For this moment we implement the well-known Ethereum Virtual Machine (EVM), and the execution model follows \cite{ETH_yellow}.


\subsubsection{Basics}

The \cvm is a stack-based architecture with $256$-bit word size.
The stack has a maximum size of $1024$ words.
The memory model is a simple word-addressed byte array.  
The machine also has an independent storage model which is a word-addressable word array (rather than byte array for the memory). 
The memory is volatile and storage is steady and maintained as part of the system state. 
All locations in both memory and storage are initialized as zero.
The program code is stored separately in a virtual ROM that is only interactable via specific instructions.

The execution of the virtual machine may reach exceptions for various reasons, including stack underflows/overflow, invalid instruction, invalid jump destination, out-of-gas and so on.
Like the out-of-gas exception, the machine halts immediately and throws an exception to the execution agent, either the transaction processor or recursively the spawning execution environment, which will catch and deal with it separately. 



\subsubsection{Gas Consumption}

The cost of execution, aka. \emph{gas}, is charged under following circumstances:
\begin{enumerate}[nosep]
	\item the execution of instructions, where each type of instructions is assigned an intrinsic amount of gas;

	\item the generation of subordinate message call or contract creation.

\end{enumerate}


\subsubsection{Storage Consumption}
	\label{subsec:storage consumption}

	\name requires a fixed amount of fund, i.e. \sunitprice, locked as collateral during the whole lifetime of each \sunitsize storage entry in the world-state.
	This fund is locked when the entry is created, and is unlocked and returned to the owner when that entry is cleared or overwritten by someone else eventually, as described in Section~\ref{sec:collateral}.
	The interest generated by the collateral is paid to miners as specified in Section~\ref{subsec:storagefee}. 
	Thus the cost of storing an entry  
	is proportional to the time length of storage usage.

	
	The owner of the collateral of a storage entry, 
	which is called ``the owner of that entry'' for simplicity, 
	essentially records who has written the latest content of that entry.
	Normally the initial owner of an entry should be the sender of the transaction that causes the creation of this entry. 
	However, in case a contract provides the collateral on behalf of the sender, the owner will be that contract instead (see Section~\ref{sec:sponsor} for details).
	When a storage entry is modified in the execution of a transaction,
	the ownership of this entry is changed,
	and the old owner's collateral for that entry is replaced by the new owner's collateral.


	If a storage entry is cleared from the world-state,
	then the corresponding collateral is unlocked and returned to the owner of that entry.
	We remark that there is no refund to the actor who causes the clearance, 
	which is distinct from the gas refunding policy in Ethereum \cite{ETH_yellow}.
	Furthermore, to ensure that unlocked collateral for storage is always returned properly, 
	\name does not allow destructing any smart contract with non-zero collateral for storage.



\subsubsection{Execution Environment}
\label{subsubsec:exe_env}
Besides the global system state $\st$ and the amount of remaining gas $g$, 
the execution agent must provide the following important information used in the execution environment, as contained in the tuple $I$:
\begin{itemize}[nosep]
	\item $I_a$, the address of the account which owns the code that is executing.
	
	\item $I_o$, the address of the original sender who originated this execution.
	
	\item $I_i$, the address of the storage owner.

	\item $I_p$, the gas price designated by the transaction that originated this execution.

	\item $I_{\vec{d}}$, the byte array that is the input data to this execution; in case the execution agent is a transaction $\tx$, this would be the transaction data $\tx_{\vec{d}}$.

	\item $I_s$, the address of the account that invoked the code; in case the execution agent is a transaction $\tx$, this would be the transaction sender's address $\sender{\tx}$.

	 \item $I_v$, the value, in \unit, passed to the recipient's account; in case the execution agent is a transaction $\tx$, this would be the transaction value $\tx_v$.

	 \item \linkdest{I__b}{$I_{\vec{b}}$}, the byte array of the machine code to be executed.

	 \item $I_{\head}$, the block header of the present block.

	 \item $I_e$, the depth of the current message-call or contract-creation in the stack.

	 \item $I_w$, the permission to make modifications to the state.

	 \item $I_\st$, the original world-state right before this execution.
\end{itemize}

The state transition is defined by the execution function $\execute$, which takes as input the current world-state $\st$, the amount of gas $g$, 
and the input $I$ as defined above,
and outputs the resultant state $\st'$, the remaining gas $g'$, the accrued substate $A$ and the resultant output $\vec{o}$.
Formally, we define it as follows:
\begin{align}
	\left( \st', g', A, \vec{o} \right) \eqdef \execute\left(\st,g, I\right)
\end{align}
where we recall that the accrued state $A$ consists of the selfdestructs set $A_\vec{s}$, the log series $A_\vec{l}$, the touched accounts $A_\vec{t}$, a series of addresses recording the owners of storage occupation $A_\vec{o}$ and a series of addresses recording the owners of storage release $A_\vec{e}$
(as described in Section~\ref{subsubsec:substate}):
\begin{align}
	A\eqdef\left(A_\vec{s},A_\vec{l},A_\vec{t},A_\vec{o},A_\vec{e} \right)
\end{align}


\subsubsection{Execution Overview}

The $\execute$ function is defined mostly following the Ethereum yellowpaper \cite{ETH_yellow}, except for a few instructions. 
For self-sufficiency we explain the definition of $\execute$ briefly.

In most practical implementations $\execute$ will be modeled as an iterative progression of the pair $(\st,\mst)$ comprising the world-state and the machine state. 
Formally, it can be recursively defined with a function $X$. This uses an iterator function $O$ (which defines the result of a single cycle of the state machine) together with functions \hyperlink{zhalt}{$Z$}, which determines if the present state is an \hyperlink{zhalt}{exceptional halting} state of the machine, and \hyperlink{hhalt}{$H$}, specifying the output data of the instruction if and only if the present state is a \hyperlink{hhalt}{normal halting} state of the machine.

Recall that the empty sequence, denoted by $\emptystring$, is not equal to the empty set, denoted by $\varnothing$; this is important when interpreting the output of $H$, which evaluates to $\varnothing$ when execution is to continue but a series (potentially empty) when execution should halt.
\begin{eqnarray}
\execute(\st, g, I) & \eqdef & (\st'\!, \mst'_{\mathrm{g}}, A, \mathbf{o}) \\
(\st', \mst'\!, A, ..., \mathbf{o}) & \eqdef & X\big((\st, \mst, A^0\!, I)\big) \\
\mst_{\mathrm{g}} & \eqdef & g \\
\mst_{\mathrm{pc}} & \eqdef & 0 \\
\mst_{\mathbf{m}} & \eqdef & (0, 0, ...) \\
\mst_{\mathrm{i}} & \eqdef & 0	\\
\mst_{\mathbf{s}} & \eqdef & \emptystring \\
\mst_{\mathbf{o}} & \eqdef & \emptystring	\\
\mst_{\mathbf{r}} & \eqdef & \emptystring
\end{eqnarray}
\begin{equation} \label{eq:X-def}
X\big( (\st, \mst, A, I) \big) \eqdef \begin{cases}
\big(\varnothing, \mst, A^0, I, \emptystring\big) & \text{if} \quad Z(\st, \mst, A, I) \\
\big(\varnothing, \mst', A^0, I, \mathbf{o}\big) & \text{if} \quad w =  \op{REVERT} \\
O(\st, \mst, A, I) \cdot \mathbf{o} & \text{if} \quad \mathbf{o} \neq \varnothing \\
X\big(O(\st, \mst, A, I)\big) & \text{otherwise} \\
\end{cases}
\end{equation}

where
\begin{eqnarray}
\mathbf{o} & \eqdef & H(\mst, I) \\
(a, b, c, d) \cdot e & \eqdef & (a, b, c, d, e) \\
\mst' & \eqdef & \mst\ \text{except:} \\
\mst'_{\mathrm{g}} & \eqdef & \mst_{\mathrm{g}} - C(\st, \mst, I)
\end{eqnarray}

Note that, when evaluating $\execute$ instead of $X$, 
the fourth element $I'$ is dropped and the remaining gas $\mst'_{\mathrm{g}}$ is extracted from the resultant machine state $\mst'$.

$X$ is thus cycled (recursively here, but implementations are generally expected to use a simple iterative loop) until either \hyperlink{zhalt}{$Z$} becomes true indicating that the present state is exceptional and that the machine must be halted and any changes discarded or until \hyperlink{hhalt}{$H$} becomes a series (rather than the empty set) indicating that the machine has reached a controlled halt.

\paragraph{Machine State.}
The machine state $\mst$ is defined as the tuple $(g, \mathrm{pc}, \vec{m}, i, \vec{s},\vec{r})$ which are the gas available, the program counter $pc \in \N_{256}$ , the memory contents, the active number of words in memory (counting continuously from position 0), the data stack contents and return stack contents. 
The memory contents $\mst_{\vec{m}}$ are a series of zeros of size $2^{256}$.
The return stack $\mst_{\vec{r}}$ is limited to $1023$ items.

For the ease of reading, the instruction mnemonics, e.g. $\op{ADD}$, should be interpreted as their numeric eqdefalents; the full table of instructions and their specifics is given in Appendix \ref{app:instruction-set}.

For the purposes of defining $Z$, $H$ and $O$, we define $w$ as the current operation to be executed:
\begin{equation}\label{eq:currentoperation}
w \eqdef 
	\begin{cases} 
		I_{\vec{b}}[\mst_{\mathrm{pc}}] & \text{if} \quad \mst_{\mathrm{pc}} < \lVert I_{\vec{b}} \rVert \\
		\hyperlink{stop}{\op{STOP}} & \text{otherwise}
	\end{cases}
\end{equation}

Furthermore, we let $\popstack$ and $\pushstack$ denote the fixed number of stack items removed from and pushed into the data stack $\mst_{\mathbf{s}}$ by executing an instruction.
Both $\popstack$ and $\pushstack$ are assumed subscriptable on the instruction. 
Similarly we define $\poprstack$ and $\pushrstack$ for the return stack $\mst_{\mathbf{r}}$, which is only accessed when entering or returning from subroutines on $\op{JUMPSUB}$ and $\op{RETURNSUB}$ instructions. 
An instruction cost function $\cost$ evaluates to the full cost, in gas, of executing the given instruction.

\paragraph{Exceptional Halting.}\hypertarget{Exceptional_Halting_function_Z}{}\linkdest{zhalt}
%
The exceptional halting function $Z$ is defined as:
\begin{equation}
	Z(\st, \mst, A, I) \eqdef
	\begin{array}[t]{ll}
		& \mst_g < C(\st, \mst, I) \quad \\
		\vee & \popstack_w = \varnothing \quad \\
		\vee & \lVert\mst_\mathbf{s}\rVert < \popstack_w \quad \\
		\vee & \left( w =  \op{JUMP} \quad \wedge \quad \mst_\mathbf{s}[0] \notin D(I_\mathbf{b})  \right) \quad \\
		\vee & \left( w =  \op{JUMPI} \quad \wedge \quad \mst_\mathbf{s}[1] \neq 0 \quad \wedge \quad \mst_\mathbf{s}[0] \notin D(I_\mathbf{b})  \right) \quad \\
		\vee & \left( w = \op{RETURNDATACOPY} \quad \wedge \quad \mst_{\mathbf{s}}[1] + \mst_{\mathbf{s}}[2] > \lVert\mst_{\mathbf{o}}\rVert \right) \quad \\
		\vee & \lVert\mst_\mathbf{s}\rVert - \popstack_w + \pushstack_w > 1024 \quad\\ 
		\vee & \left(\neg I_{\mathrm{w}} \quad \wedge \quad W(w, \mst)\right)\quad \\
		\vee & \left( w = \op{SELFDESTRUCT} \quad \wedge \quad \mathsf{Type}_{\mst_{\mathbf{s}}[0]\mbox{ mod }2^{160}}\notin \set{\typereserved,\typenormal,\typecontract}\right) \\
		\vee & \left( w = \op{SELFDESTRUCT} \quad \wedge \quad \st[I_a]_o> 0\right)
	\end{array}
\end{equation}
where
\begin{equation}
W(w, \mst) \eqdef \\
\begin{array}[t]{ll}
	& w \in \{ \op{CREATE},  \op{CREATE2},  \op{SSTORE}, \op{SUICIDE}\} \quad \\
	\vee & \left(\op{LOG0} \le w \wedge w \le  \op{LOG4} \right)\\
	\vee & \left(w \in \{ \op{CALL},  \op{CALLCODE}\} \wedge \mst_{\mathbf{s}}[2] \neq 0\right)
\end{array}
\end{equation}

This states that the execution is in an exceptional halting state if there is insufficient gas, if the instruction is invalid (and therefore its $\popstack$ subscript is undefined), if there are insufficient stack items, if a $\op{JUMP}$/$\op{JUMPI}$ destination is invalid, 
if the output data size $\lVert\mst_{\mathbf{o}}\rVert$ is insufficient for the copy-output-data operation specified in a $\op{RETURNDATACOPY}$ instruction,
or if the new stack size would be larger than $1024$ or state modification is attempted during a static call. The astute reader will realize that this implies that no instruction can, through its execution, cause an exceptional halt.

\paragraph{Jump Destination Validity.}
We previously used $D$ as the function to determine the set of valid jump destinations given the code that is being run. We define this as any position in the code occupied by a  $\op{JUMPDEST}$ instruction.

All such positions must be on valid instruction boundaries, rather than sitting in the data portion of  $\op{PUSH*}$ operations and must appear within the explicitly defined portion of the code (rather than in the implicitly defined \hyperlink{stop}{$\op{STOP}$} operations that trail it).

Formally:
\begin{equation}
D(\mathbf{c}) \eqdef D_{J}(\mathbf{c}, 0)
\end{equation}

where:
\begin{equation}
D_{J}(\mathbf{c}, i) \eqdef \begin{cases}
\{\} & \text{if} \quad i \geqslant \lVert \mathbf{c} \rVert  \\
\{ i \} \cup D_{J}(\mathbf{c}, N(i, \mathbf{c}[i])) & \text{if} \quad \mathbf{c}[i] =  \op{JUMPDEST} \\
D_{J}(\mathbf{c}, N(i, \mathbf{c}[i])) & \text{otherwise} \\
\end{cases}
\end{equation}

where $N$ is the next valid instruction position in the code, skipping the data of a  $\op{PUSH*}$ instruction, if any:
\begin{equation}\label{eq:next-instruction}
N(i, w) \eqdef \begin{cases}
i + w -  \op{PUSH1} + 2 & \text{if} \quad w \in [ \op{PUSH1},  \op{PUSH32}] \\
i + 1 & \text{otherwise} \end{cases}
\end{equation}

\paragraph{Normal Halting.}\hypertarget{normal_halting_function_H}{}\linkdest{hhalt}

The normal halting function $H$ is defined:
\begin{equation}
H(\mst, I) \eqdef 
	\begin{cases}
	H_{\text{\tiny RETURN}}(\mst) & \text{if} \quad w \in \{ \op{\hyperlink{RETURN}{RETURN}},  \op{REVERT}\} \\
	\emptystring \quad\quad& \text{if} \quad w \in \{  \op{\hyperlink{stop}{STOP}},  \op{\hyperlink{selfdestruct}{SUICIDE}} \} \\
	\varnothing \quad\quad& \text{otherwise}
	\end{cases}
\end{equation}

The data-returning halt operations, \hyperlink{RETURN}{ \op{RETURN}} and  \op{REVERT}, have a special function $H_{\text{\tiny RETURN}}$. Note also the difference between the empty sequence and the empty set as discussed \hyperlink{empty_sequence_vs_empty_set}{here}.

\subsubsection{The Execution Cycle}

Stack items are added or removed from the left-most, lower-indexed portion of the series; all other items remain unchanged:
\begin{eqnarray}
O\big((\st, \mst, A, I)\big) & \eqdef & (\st', \mst', A', I) \\
\Delta & \eqdef & \pushstack_{w} - \popstack_{w} \\
\lVert\mst'_{\mathbf{s}}\rVert & \eqdef & \lVert\mst_{\mathbf{s}}\rVert + \Delta \\
\quad \forall x \in \left[ \pushstack_{w}, \lVert\mst'_{\mathbf{s}}\rVert -1 \right]: \mst'_{\mathbf{s}}[x] & \eqdef & \mst_{\mathbf{s}}\left[x-\Delta \right]
\end{eqnarray}

The gas is reduced by the instruction's gas cost.
\begin{eqnarray}
	\quad \mst'_{g} & \eqdef & \mst_{g} - C(\st, \mst, I) \label{eq:mu_pc}
\end{eqnarray}

For most instructions, the program counter $\mathrm{pc}$ increases by $1$ on each cycle, except for following instructions: $\op{PUSH*}$, $\op{JUMP}$, $\op{JUMPI}$, $\op{JUMPSUB}$, $\op{RETURNSUB}$.
The next valid instruction position for $\op{PUSH*}$ instructions is already specified in $N$ as in \cref{eq:next-instruction}. 
We assume a function $J$, subscripted by one instruction from $\big\{\op{JUMP}$, $\op{JUMPI}$, $\op{JUMPSUB}$, $\op{RETURNSUB}\big\}$, which evaluates to the according value:
\begin{eqnarray}\label{eq:u_pc}
	\quad \mst'_{\mathrm{pc}} & \eqdef & 
	\begin{cases}
		\hyperlink{JUMP}{J_{\op{JUMP}}}(\mst) & \text{if} \quad w =  \op{JUMP} \\
		\hyperlink{JUMPI}{J_{\op{JUMPI}}}(\mst) & \text{if} \quad w =  \op{JUMPI} \\
		\hyperlink{JUMPSUB}{J_{\op{JUMPSUB}}}(\mst) & \text{if} \quad w =  \op{JUMPSUB} \\
		\hyperlink{RETURNSUB}{J_{\op{RETURNSUB}}}(\mst) & \text{if} \quad w =  \op{RETURNSUB} \\
		N(\mst_{\mathrm{pc}}, w) & \text{otherwise}
	\end{cases}
\end{eqnarray}

In general, we assume the memory, self-destruct set and system state do not change:
\begin{eqnarray}
\mst'_{\mathbf{m}} & \eqdef & \mst_{\mathbf{m}} \\
\mst'_{\mathrm{i}} & \eqdef & \mst_{\mathrm{i}} \\
A' & \eqdef & A \\
\st' & \eqdef & \st
\end{eqnarray}

However, instructions do typically alter one or several components of these values. Altered components listed by instruction are noted in Appendix \ref{app:vm}, alongside values for $\pushstack$, $\popstack$, $\pushrstack,\poprstack$ and a formal description of the gas requirements.

\subsubsection{Difference from Ethereum}
The execution function $\execute$ follows nearly the same definition as in Ethereum yellowpaper \cite{ETH_yellow} except for a few instructions. 
When executing $O(\st, \mu, A, I) \eqdef (\st' , \mu' , A' , I')$ 
for the iterator function $O$ which defines the result of a single cycle of the state machine,
{\name} differs from Ethereum on following instructions. 


\paragraph{Sub-call operations.} 
{\name} has two additional parameters comparing with Ethereum: 
the recipient addresses call-state $\vec{t}$ and the storage owner $i$.
In sub-call operations such as $\op{CREATE}$, $\op{CALL}$, $\op{CALLCODE}$, $\op{DELEGATECALL}$, and $\op{STATICCALL}$,  
the recipient addresses $I_\vec{t}\cdot I_a$ and storage owner $I_i$ are passed to $\creation$ and $\execution$ as part of the execution environment $I$. 

\paragraph{Re-entrance Protection.}

When calling a contract, {\name} virtual machine makes sure that re-entrance attack is impossible by preventing re-entrance message call, except the message call matches some requirements which make re-entrance attack impossible. 

To be specific, the {\name} virtual machine maintains a call stack $I_\vec{t}$ and 
prevents the message call
when the callee is already in the call stack but different from the caller before executing the code invoked by each message call.
By requiring that the callee being different from the caller, it is still allowed to call and execute other functions in the caller's contract.
Because in such cases the developer should be able to fully anticipate the execution flow
and we do not consider it necessary to trigger the re-entrance protection.

If the message call is indeed re-entering some other contract in the call stack,
the re-entrance protection is triggered 
unless two requirements are satisfied: a) the available gas in sub-execution of message call is no more than $G_{stipend}$, 
b) the message call has no call data. 
It means that the message call generated from solidity built-in function {\tt send()} and {\tt transfer()} will never trigger
re-entrance protection. This design allows some widely used contract logic currently, 
e.g. withdrawing \cfx from a contract when the transfer has to happen via a re-entrance call. 
%
When the re-entrance protection is triggered, {\name} virtual machine deals with it in the same way as ``call stack overflow'' or ``not enough balance for value transfer''. It stops calling the next contract and refunds all the available gas.



\paragraph{$\op{SSTORE}$ operation.} 
The $\op{SSTORE}$ operation transforms $(\st,A)$ into $(\st',A')$ as follows:

\begin{align}
	\st'   &\eqdef \Phi(\st,I_a, \mst_{\sf s}[0],\mst_{\sf s}[1],I_i) \\ 
	A'     &\eqdef A
\end{align}

where $\Phi$ is defined in section~\ref{sec:storage_maintain}.

In Ethereum, the cost of operation $\op{SSTORE}$ is $G_{sset}=20000$ gas when the storage value is set to non-zero from zero,
and  $G_{sreset}=5000$ gas when the storage value is set to zero. 
Ethereum will also refund $R_{sclear}=15000$ gas when the storage value is set to zero from non-zero. 

In {\name}, since cost of using storage is reflected by collateral for storage, there is no need to charge space consumption in gas. 
Thus {\name} charged $G_{sset}=5000$ gas for all the $\op{SSTORE}$ operation, 
regardless of the storage value,
and there is no gas refund either. 
Furthermore, the {\name} ledger $\st$ tracks the owner of every storage entry with non-zero value. 
The execution substate $A$ records all changes on ownership of storage entries. 

\paragraph{$\op{SUICIDE}$ operation.} When executing the $\op{SUICIDE}$ operation on $(\st,\mu,A,I)$, the destruction process is interrupted and an exception will be generated if the contract has non-zero collateral for storage (i.e. $\st[I_a]_o>0$) or the address receiving refund balance is invalid (i.e. $\mathsf{Type}_{\mst_{\mathbf{s}}[0]\mod2^{160}}\notin\set{\typereserved,\typenormal,\typecontract}$). Otherwise, the $\op{SELFDESTRUCT}$ operation transforms $(\st,A)$ into $(\st',A')$ by function $(\st',A')\eqdef \Psi(\st,A)$, which is defined in section~\ref{sec:contract_destruct}. 

Compared with Ethereum, Conflux updates the storage collateral of code owner for destructed contract and refunds the sponsor balance for gas at this time. Notice that the sponsor balance for collateral will not be refunded until all the storage collateral has been charged from or refunded to account balance. 

\paragraph{Subroutine operation.} Ethereum introduces $\op{BEGINSUB}$, $\op{JUMPSUB}$, $\op{RETURNSUB}$ instructions in EIP-2315, which is not listed in its yellowpaper. 
{\name} implements this instruction with identical behavior as Ethereum.