% !TEX root = ./tech-specification.tex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{交易处理}
%\section{Transaction Processing}
\label{sec:tx_processing}

\name 实现了与以太坊 \cite{ETH_yellow} 相同的虚拟机。
%\name implements the same virtual machine as Ethereum \cite{ETH_yellow}. 
一个交易的执行定义了转换函数 $\Upsilon(\st,\tx,\vec{L})$，其与以太坊的全局状态转换函数类似。
%The execution of a transaction defines the transform function $\Upsilon(\st,\tx,\vec{L})$, which is similar with Ethereum's state transition function.

\subsection{Overview}

在下文中我们将阐述 \name 有关交易执行的具体设计。
%In what follows we focus on the \name specific designs in the execution.

\paragraph{燃料与支付}
\label{subsec:gas_and_pay}

如同第 \ref{sec:tx} 节中的定义样，每笔交易 $\tx$ 的两个域 {\bf 燃料量} 和 {\bf 燃料价格} 标明交易所需燃料 $\tx_g$ 和燃料单位价格 $\tx_p$ 的具体数值。
%As defined in Section~\ref{sec:tx} every transaction $\tx$ has two fields of {\bf gasLimit} and {\bf gasPrice} that declare the specific amount of associated gas $\tx_g$ and the price $\tx_p$ of per unit gas.
开始执行一笔交易 $\tx$ 时，应支付的燃料总价为 $\tx_g \times \tx_p$；当负责支付燃料消耗费用的一方负担不起该费用时，交易 $\tx$ 将被视为无效。
%When starting the execution of a transaction $\tx$, the purchase of gas happens at the price $\tx_g \times \tx_p$ and the transaction $\tx$ is considered invalid if the actor responsible for the cost of gas consumption cannot afford such a purchase.
正常情况下，$\tx$ 的发送方 $\sender{\tx}$ 将承担燃料消耗费用。但燃料消耗可能由交易调用的合约赞助（详见下文）。
%Normally $\sender{\tx}$, the sender of $\tx$, is responsible for the cost of gas consumption. But the gas consumption maybe sponsored by called contract sometimes. (See the following paragraph for details.) 
与以太坊相似，燃料不存在于交易执行过程以外。
%Like in Ethereum, gas does not exist outside the execution of transactions.


未被使用的燃料将在交易 $\tx$ 执行后退回，但退回额度不超过购买燃料所花总价的四分之一。
%The unused gas can be refunded after the transaction $\tx$ is executed, but no more than a quarter of the total value spent on purchasing. 
因此，\emph{可退还燃料量} $g^{\dagger}$ 等于以下两个中更小的值：$\tx$ \textbf{燃料量} 的四分之一和 \emph{合理剩余燃料} $g'$。即，$g^{\dagger}\eqdef \min\set{g', \tx_g/4}$。
%Thus, the \emph{refundable amount of gas} $g^{\dagger}$ is the minimum of the \emph{legitimately remaining gas} $g'$ and a quarter of the \textbf{gasLimit} of $\tx$,i.e. $g^{\dagger}\eqdef \min\set{g', \tx_g/4}$, 
特别地，若发送方导致 $\tx$ 执行失败，则理论上没有燃料可退还（即 $g^{\dagger} = g' = 0$）。
%where in principle no gas is refundable (i.e. $g^{\dagger} = g' = 0$) if the execution of $\tx$ fails due to the sender's fault. 
最初为 $\tx$ 购买燃料的一方将收到退款 $g^{\dagger}\times\tx_p$。而支付给已消耗燃料的 \coinsign 为
%The actor who initially purchased the gas for $\tx$ will get the refund of $g^{\dagger}\times\tx_p$. And the \coinsign paid for the consumed gas is 
	%
\begin{align}
	\left(\tx_g-g^{\dagger}\right)\times \tx_p.
\end{align}
	%
如果 $\tx$ 未被执行（即，如第 \ref{sec:tx validate} 中定义一般，仅当 $R_z=2$ 时），没有燃料需要被支付。
	%If the $\tx$ is not executed (i.e. only when $R_z=2$ as in Section~\ref{sec:tx validate})), no gas will be charged. 
若发送方 $\sender{\tx}$ 无法负担燃料费，发送方的全部余额将被用于支付燃料费，此实际收取的燃料费将被记录在收据 $R_f$ 中。
	%If the sender $\sender{\tx}$ can not afford gas fee, all its the remained balance of sender $\sender{\tx}$ will be charged as gas fee. The actual charged gas fee will be record in receipt $R_f$. 


支付完毕的燃料费将加入矿工奖励池。因此，更高的燃料价格使发送者花费更多的同时，也将增加该交易被及时处理的概率。
%The charged gas fee is added to the reward pool for miners. Thus in general a higher gas price on a transaction would cost the sender more but also increase the chance of being processed timely.


计算整个区块的累计燃料消耗时，不可退还的燃料 $g^{\dagger} - g'$ 将不被纳入考量。
%In computing the accumulated gas used of the whole block, the non-refundable gas $g^{\dagger} - g'$ is not taken into consideration. 
但当发送方 $\sender{\tx}$ 无法负担燃料费时，即使实际收取的燃料费少于 $\tx_p\times\tx_g$，我们也认为消耗的燃料量即是 $\tx_g$。
%But in case the sender $\sender{\tx}$ can not afford gas fee, the gas used is considered as $\tx_g$, even if the actual charged gas fee is less than $\tx_p\times\tx_g$. The gas used is also recorded in receipt $R_g$. 

\paragraph{存储上限和存储抵押}
%\paragraph{Storage Limit and Storage Collateral}

每笔交易都有一个 \textbf{存储上限} 域，表明当前交易可增加的最大存储字节 $\tx_\ell$。
%Every transactions also have a filed of \textbf{storage limit} that declare the maximum storage bytes $\tx_\ell$ increasing for the present transaction. 
执行交易前，除燃料费用和转账额以外，发送方 $\sender{\tx}$ 必须有足够余额为所需 \textbf{存储上限} 支付存储抵押，即 $\tx_\ell\times\collateralperbyte\;\unit$。
%Before transaction execution, besides gas fee and transferred value, the sender $\sender{\tx}$ must have enough balance for storage collateral for specified \textbf{storageLimit}, i.e., $\tx_\ell\times\collateralperbyte\;\unit$. 
不同于燃料费，在执行交易前这些抵押将不被收取或锁定。
%Unlike the gas fee, these collateral will not be charged or locked at this time. 
在交易执行完成时，若发送方没有足够余额为实际增加的存储支付抵押，或实际增加的存储字节超过了存储上限，交易执行将失败。
%At the end of transaction execution, if the sender doesn't have enough balance paying for the increased storage collateral or the increased storage bytes of sender exceeds storage limit, the transaction execution fails. 
更多有关存储抵押的细节详见第 \ref{sec:collateral} 节。
%More details for collateral for storage is specified in section~\ref{sec:collateral}. 

\paragraph{赞助}
%\paragraph{Sponsorship}

当交易 $\tx$ 调用一个带有 \textbf{燃料资助人} 的智能合约 $\contract$，且 $\tx$ 满足 \cref{eq:whitelist} 中定义的函数 $\mathsf{Whitelist}(\cdot)$ 要求而有资格使用该赞助时，
%In case the transaction $\tx$ is calling a smart contract $\contract$ with \textbf{sponsor for gas} and $\tx$ is qualified for the subsidy as checked in function $\mathsf{Whitelist}(\cdot)$ defined in \cref{eq:whitelist}, 
若 $\contract$ 有足够的 \textbf{燃料资助余额} 且交易 \textbf{燃料上限} $\tx_g$ 不超过 {\bf 燃料资助上限}，
$\contract$ 将负责购买燃料；
%$\contract$ is responsible for the purchase of gas if it has sufficient \textbf{sponsor balance for gas} and the transaction \textbf{gasLimit} $\tx_g$ does not exceed the {\bf sponsor limit for gas}, 
否则，交易发送方 $\sender{\tx}$ 仍负责购买燃料全额。
%and otherwise the sender $\sender{\tx}$ is still responsible for the whole purchase of gas as if there were no sponsor at all. 
我们正式定义函数 $\mathsf{GasElig}(\st,\tx)$ 来检查交易 $\tx$ 是否有资格使用燃料赞助，同时定义 $\mathsf{GasSpr}(\st,\tx)$ 来检查实际上 $\tx$ 是否使用了燃料赞助。
%Formally, we define function $\mathsf{GasElig}(\st,\tx)$ to check whether transaction $\tx$ is eligible for gas consumption sponsorship and define function $\mathsf{GasSpr}(\st,\tx)$ to check whether $\tx$ is actually sponsored for gas consumption. 
\begin{align}
\mathsf{GasElig}(\st,\tx)&\eqdef \quad \mathrm{Type}_{\tx_a}=\typecontract \;\wedge\; \mathsf{Whitelist}(\st,\sender{\tx},\contract) \;\wedge\; \st[\tx_a]_p[\mathsf{gas}]_a\neq 0 \;\wedge\; \tx_g\times\tx_p \le \st[\tx_a]_p[\mathsf{limit}] \\
\mathsf{GasSpr}(\st,\tx) &\eqdef\quad  \mathsf{GasElig}(\st,\tx) \;\wedge\; \st[\tx_a]_p[{\sf gas}]_b\ge \tx_g\times\tx_p
\end{align}
%
其中，函数 $\mathsf{Whitelist}(\cdot)$ 在 \cref{eq:whitelist} 有详细定义。
%where function $\mathsf{Whitelist}(\cdot)$ is defined in \cref{eq:whitelist}. 

若一个合约存在 \textbf{存储抵押资助人}， 存储抵押费用也能被合约赞助。正式定义下，
%If a contract has \textbf{sponsor for collateral}, the storage collateral can also be sposnored by a contract. Formally,
\begin{align}
\mathsf{ColElig}(\st,\tx) &\eqdef \quad \mathrm{Type}_{\tx_a}=\typecontract \;\wedge\; \mathsf{Whitelist}(\st,\sender{\tx},\contract) \;\wedge\; \st[\tx_a]_p[\mathsf{col}]_a\neq 0 \\
\mathsf{ColSpr}(\st,\tx) &\eqdef\quad  \mathsf{ColElig}(\st,\tx) \;\wedge\; \st[\tx_a]_p[{\sf col}]_b\ge \tx_\ell\times \collateralperbyte
\end{align}

\subsection{交易执行}
%\subsection{Transaction Execution}

\subsubsection{执行前验证}
%\subsection{Pre-execution Validation}
\label{sec:tx validate}

在被执行前，一笔处于待执行列中的交易 $\tx$ 必须通过以下有关交易合法性的第二轮测试：
%Before being executed, a transaction $\tx$ in the processing queue must pass the following secondary test of intrinsic validity. 
\begin{enumerate}[nosep]
	\item 当前纪元处于 \textbf{epochHeight} 所指明的区间之内，即当前纪元高度在 $[\tx_e - \txepochbound, \tx_e + \txepochbound]$ 之间。
	%\item The current epoch is in the range specified by \textbf{epochHeight}, i.e. current epoch height is in $[\tx_e - \txepochbound, \tx_e + \txepochbound]$.
	
	\item 交易 \textbf{序列号} 合法，即 $\tx_n = \st\left[\sender{\tx}\right]_n$，其中 $\st$ 表示当前世界状态。
	%\item The transaction \textbf{nonce} is valid, i.e. $\tx_n = \st\left[\sender{\tx}\right]_n$ where $\st$ is the current world-state.

	\item 接收方地址合法，即 $\tx_a$ 的（前 $4$ 位）类型标志属于 $\set{\typereserved,\typenormal,\typecontract}$。
    %\item The recipient address is valid , i.e. the type indicator (first $4$-bit) of $\tx_a$ belongs to $\set{\typereserved,\typenormal,\typecontract}$.
\end{enumerate}

需要注意的是交易的本地合法性，即 $\rlp$ 格式和签名有效性，
%Note that the local legality of the transaction, e.g. the $\rlp$ format and the validity of signature, 
已在有关交易合法性的第一轮测试中（定义见第 \ref{sec:block validate} 节）得到验证。第一轮测试在将相应区块纳入 \name 树图时进行，因此在第二轮测试中本地合法性将不被二次检查。
%is already verified in the first intrinsic validity test before accepting the corresponding block into the \name \tg, as discussed in Section~\ref{sec:block validate}, and will not be checked again at this moment.

若 $\tx$ 未能通过这些检查，系统将不执行该交易，不增加账户序列号，也不对此交易收取交易费用。
%If $\tx$ fails at these checks, the transaction will not be executed, the nonce for account will not increase and no transaction fee is charged for such transaction. 
用 $R'$ 表示前一笔交易的收据，
%Let $R'$ be the receipt of last transaction.
则当前交易的收据将被设为：
%Then the receipt of current transaction will be set as follows:
\begin{align}
	R_u=R'_u && R_f=0 && R_g=0 && R_{\bf l}=\emptystring && R_z=2 && R_s=0 && R_{\bf o}=\emptystring && R_{\bf i}=\emptystring
\end{align}
%
布隆过滤器 $R_b$ 根据日志 $R_{\bf l}$ 计算而已。
%(The bloom filter $R_b$ of log $R_{\bf l}$ is computed accordingly. )

若 $\tx$ 通过了以上交易前检查，$\tx$ 的执行过程如本节余下内容所述。
%If $\tx$ passes all the above pre-execution checks, the execution of $\tx$ is as specified in the rest of this section.


\subsubsection{预处理}
%\subsubsection{Preprocessing}
\label{subsubsec:preprocessing}

在 $\tx$ 的预处理阶段，为确保未来成功操作，$\sender{\tx}$（或资助人） 的余额将被检查。
%In the preprocessing phase of $\tx$, the balance of $\sender{\tx}$ (and the sponsor, if applicable) is examined so that the payment for any further operation is assured.
若 $\tx$ 通过了预处理，世界状态将从 $\st$ 转变为 $\st^0\eqdef \st^{**}$；否则，世界状态将变为 $\st'$，而交易 $\tx$ 的执行将被中止。
%The world-state will be transformed from $\st$ into $\st^0\eqdef \st^{**}$ if $\tx$ passes the preprocessing, or directly into $\st'$ and the execution is aborted if $\tx$ fails at any step.

\paragraph{序列号增加}
%\paragraph{Nonce incremental.}
交易执行的开始将对世界状态 $\st$ 产生一个不可更改的变动：
%The beginning of execution causes an irrevocable changed to the state $\st$: 
发送方的账户序列号 $\sender{\tx}_n$ 将增加一。
%the nonce of the sender, $\sender{\tx}_n$, is incremented by one. 
%
世界状态 $\st^*$ 的定义如下：
%We define the state $\st^*$:
\begin{align}
	\st^*  &\eqdef \st \qquad \mbox{  except:}\\
	\st^*\left[\sender{\tx} \right]_n &\eqdef \st\left[\sender{\tx} \right]_n+1 
\end{align}

\paragraph{燃料消耗支付验证}
%\paragraph{Gas consumption payment validation.}

进行交易 $\tx$ 的提前支付时，系统首先明确燃料消耗是否有赞助。
%The up-front payment of a transaction $\tx$ first figures out whether the gas consumption is sponsored. 
若 $\tx$ 有资格使用燃料赞助，且其调用的合约有足够的 \textbf{燃料资助余额}，则交易 $\tx$ 有燃料赞助。
%$\tx$ is sponsored on gas consumption if $\tx$ is eligible for sponsorship on gas consumption and the calling contract has sufficient \textbf{sponsor balance for gas fee}. 
\begin{itemize}
	\item 若 $\tx$ 的燃料消耗使用了赞助，燃料费支付后的世界状态 $\st^{**}$ 定义如下：
	%\item If the gas consumption of $\tx$ is sponsored, the world-state $\st^{**}$ after gas consumption payment is as follows: 
	\begin{align}
		\st^{**}  &\eqdef \st^* \qquad \mbox{  except:}\\
		\st^{**}\left[\contract_{addr}\right]_p[{\sf gas}]_b &\eqdef \st^*\left[I_a\right]_p[{\sf gas}]_b-\tx_g\times\tx_p
	\end{align} 
	
	\item 否则，发送方 $\sender{\tx}$ 需支付燃料费。
	%\item Otherwise, the sender $\sender{\tx}$ is required to pay for the gas consumption. 
	$\sender{\tx}$ 的余额应满足 $\st^{*} \left[\sender{\tx}\right]_b \ge \tx_g\times\tx_p+\tx_v$；否则，系统将生成一个 \emph{余额不足例外}。
	%The balance of $\sender{\tx}$ should satisfy $\st^{*} \left[\sender{\tx}\right]_b \ge \tx_g\times\tx_p+\tx_v$ and otherwise a \emph{not enough balance exception} is generated. 
	处理此 \emph{余额不足例外} 的方法将在之后讨论。
	%The handling of \emph{not enough balance exception} will be discussed later.
	燃料费支付后的世界状态定义如下：
	%The world-state after the gas consumption payment is defined as: 
	\begin{align}
		\st^{**}  &\eqdef \st^* \qquad \mbox{  except:}\\
		\st^{**} \left[\sender{\tx}\right]_b &\eqdef \max\set{\st^*\left[\sender{\tx}\right]_b-\tx_g\times\tx_p,0}
	\end{align}
\end{itemize}

\paragraph{存储上限验证}
%\paragraph{Storage limit validation.}

确定燃料费用后，Conflux 将决定由谁来支付存储抵押。
%After charging, Conflux decides who is responsible for storage collateral. 
若 $\tx$ 有资格使用存储抵押赞助，且被调用的合约 $\contract=\tx_a$ 有充足的 \textbf{存储抵押资助余额}，则合约 $\contract$ 将负责支付由执行 $\tx$ 产生的存储抵押，并成为修改项的所有者。
%If $\tx$ is eligible for sponsorship on storage collateral and calling contract $\contract=\tx_a$ has enough \textbf{sponsor balance for collateral}, contract $\contract$ is responsible for the storage collateral resulted in the execution of $\tx$ and will be the owner of modified entries. 
%
否则，发送方 $\sender{\tx}$ 为修改项的所有者，并有义务支付相应的存储抵押。
%Otherwise, the sender $\sender{\tx}$ is the owner of modified entries and has the obligation to pay corresponding storage collateral. 
%
\begin{align}
	\mathsf{ColOwner}(\st,\tx) &\eqdef\left\{ \begin{array}{ll}
		\tx_a & \text{if } \mathsf{ColSpr}(\st,\tx) = \true \\ 
		\sender{\tx} & \text{if } \mathsf{ColSpr}(\st,\tx) = \false \\ 
	\end{array}\right.
\end{align}

若 $\sender{\tx}$ 是存储所有者，但其账户在转帐 $\tx_v$ 后无法负担 {\bf 存储上限} 所标明的抵押全额，
%If $\sender{\tx}$ is the storage owner but his balance cannot afford the full collateral as declared in {\bf storageLimit} after transferring value $\tx_v$, 
即 $\st^{**}[\sender{\tx}]_b<\tx_v+\tx_\ell\times 10^{18}/1024$，
%i.e. $\st^{**}[\sender{\tx}]_b<\tx_v+\tx_\ell\times 10^{18}/1024$, 
那么 $\tx$ 的执行将因为 \emph{余额不足例外} 失败。
%then the execution of $\tx$ fails due to \emph{not enough balance exception}. 

\paragraph{处理余额不足例外} 
%\paragraph{Handling not enough balance exception.} 

每当 $\tx$ 在预处理过程中生成一个 \emph{余额不足例外} 时，$\tx$ 的执行将失败，且 $\tx$ 将不继续执行。
%Whenever the preprocessing of $\tx$ generates a \emph{not enough balance exception} during preprocessing, the execution of $\tx$ fails and there will be no further execution of $\tx$. 
为明确该例外是否由合约的赞助余额不足造成，交易执行前的发送方账户余额（即 $\st[\sender{\tx}]_b$）将与一个 \emph{最低要求余额（minimum required balance）} 做比较。该 \emph{最低要求余额} 定义如下： 
%To figure out whether this exception caused by the insufficient sponsorship balance in contract, the sender balance before transaction execution (i.e. $\st[\sender{\tx}]_b$) is compared with a \emph{minimum required balance} defined as
\begin{align}
	\tx_v+(1-\mathbb{I}(\mathsf{GasElig}(\st,\tx)))\times \tx_g \times \tx_p + (1-\mathbb{I}(\mathsf{ColElig}(\st,\tx)))\times \tx_\ell \times \collateralperbyte.
\end{align}

若 $\st[\sender{\tx}]_b$ 大于 \emph{最低要求余额}，系统将认定 \emph{余额不足例外} 不因发送方 $\sender{\tx}$ 而产生。
%If $\st[\sender{\tx}]_b$ has enough balance for \emph{minimum required balance}, the sender $\sender{\tx}$ is considered not responsible for the generated \emph{not enough balance exception}. 
这种情况下，例外所造成的世界状态 $\st'$ 将被恢复为 $\st$；为使 $\tx$ 可被再次使用，发送方的账户序列号将被重设
%In this case, the resultant world-state $\st'$ is reverted to $\st$, the nonce of sender is reset so that $\tx$ is reusable. 
收据由以下项组成（其中 $R'$ 表示上一笔交易的收据）：
%The receipt is composed as follows (where $R'$ refers the receipt of last transaction):
\begin{align}
	&R_u=R'_u && R_f=0 && R_g=0 && R_{\bf l}=\emptystring \\
	&R_z=2 && R_s=0 && R_{\bf o}=\emptystring && R_{\bf i}=\emptystring
\end{align}

其他情况下，例外因发送方 $\sender{\tx}$ 而产生。
%In other cases, sender $\sender{\tx}$ is responsible for the exception. 
例外所造成的世界状态将从 $\st'$ 恢复为 $\st^{**}$。若发送方存在（即 $\st[\sender{\tx}]\neq\varnothing$），则收据由以下项组成：
%The resultant world-state is $\st'$ is reverted to $\st^{**}$ and the receipt is composed as follows if sender is non-existent. (i.e. $\st[\sender{\tx}]\neq\varnothing$).
\begin{align}
	&R_u=R'_u+\tx_g && R_f=\min\{\tx_g\times\tx_p,\st[\sender{\tx}]_b\} && R_g=\mathsf{GasElig}(\st,\tx) && R_{\bf l}=\emptystring \\
	&R_z=1 && R_s=0 && R_{\bf o}=\emptystring && R_{\bf i}=\emptystring
\end{align}

若例外因发送方 $\sender{\tx}$ 而产生，且发送方不存在，例外所造成的世界状态将从 $\st'$ 恢复为 $\st$，收据如下：
%If sender $\sender{\tx}$ is responsible for the exception and the sender is empty, the resultant world-state is $\st'$ is reverted to $\st$. The receipt is composed as follows
\begin{align}
&R_u=R'_u && R_f=0 && R_g=0 && R_{\bf l}=\emptystring \\
&R_z=2 && R_s=0 && R_{\bf o}=\emptystring && R_{\bf i}=\emptystring
\end{align}


\subsubsection{执行子状态}
%\subsubsection{Execution Substate}
\label{subsubsec:substate}

\emph{交易子状态} $A$ 是一个在执行中积累中间信息的三元组。
%The \emph{transaction substate} $A$ is a three tuple which accrues intermediate information during execution. 
\begin{align}
	A\eqdef \left( A_{\bf s}, A_{\bf l}, A_{\bf c}\right)
\end{align}
$A$ 的组成部分定义如下：
%The components of $A$ are defined as follows: 
\begin{itemize}[nosep]
	\item $A_{\bf s}$ 是一个边执行边自毁的账户集合，在交易完成时其将被遗弃。
	%\item $A_{\bf s}$ is the self-destruct set of accounts that will be discarded upon the transaction's completion.

	\item $A_{\bf l}$ 是一个虚拟机代码执行中产生的可索引日志序列，其允许轻量级客户端追踪一个合约的执行。
	%\item $A_{\bf l}$ is the log series consisting of indexable ``checkpoints'' in the VM code execution, allowing light clients to track the execution of a contract.

	\item $A_{\bf c}$ 是一个键值对集合，记录着每个地址的存储抵押变化值。与世界状态相似，我们用 $A_{\bf c}[k]=\varnothing$ 表示键 $k$ 不存在的情况，并使用 $A_{\bf c}[k]=0$ 简代 $A_{\bf c}[k]=\varnothing$。
	%\item $A_{\bf c}$ is the set of key-value pairs for the storage collateral changes for each address. Similar with the world state, we write $A_{\bf c}[k]=\varnothing$ for the case that the key $k$ does not exist and regard $A_{\bf c}[k]=\varnothing$ as $A_{\bf c}[k]=0$.

	%\item $A_{\bf t}$ 是一个交易所涉及账户的集合，其中空账户将在交易完成时被删除。
	%\item $A_{\bf t}$ is the set of touched accounts, of which the empty ones will be deleted on the transaction's completion.
\end{itemize}

空白的子状态 $A^0$，也即初始子状态，没有账户自毁记录、日志，和所涉及账户记录。$A^0$ 的正式定义为
%The empty substate $A^0$, which is also the initial substate, has no self-destructs, no logs, no touched accounts, and zero refund. Formally, $A^0$ is defined as
\begin{align}
	A^0\eqdef \left( \varnothing, \emptystring, \varnothing\right)
\end{align}

对任意两个子状态 $A^1$ 和 $A^2$，两者累计的子状态 $A\eqdef A^1\Cup A^2$ 定义如下：
%For any two substate $A^1$ and $A^2$, the accrued substate $A\eqdef A^1\Cup A^2$ is defined by 
\begin{align}
	A_{\bf s} &\eqdef A^1_{\bf s} \cup A^2_{\bf s} \\ 
	A_{\bf l} &\eqdef A^1_{\bf l} \cdot A^2_{\bf l} \\
	\forall a\in\B_{160},\; A_{\bf c}[a] & \eqdef A^1_{\bf c}[a]+A^2_{\bf c}[a]
	% A_{\bf t} &\eqdef A^1_{\bf t} \cup A^2_{\bf t} 
\end{align}


\subsubsection{类型依存性执行}
%\subsubsection{Type dependent execution}

若交易通过了预处理阶段，
%If transaction passes the preprocessing, 
{\name} 将根据 \emph{执行前临时状态} $\st^0$ 评估其 \emph{执行后临时状态} $\st^P$。
而\emph{执行前临时状态} $\st^0$ 取决于 $\tx_a$ 所明确的交易类型：创建合约或消息调用。
%then {\name} evaluates the \emph{post-execution provisional state} $\st^P$ from \emph{pre-execution provisional state} $\st^0$ depending on the transaction type as specified in $\tx_a$: either contract creation or message call. 
%
下一步计算可用的燃料为 $g\eqdef \tx_g-g_0$，其中 $g_0$ 表示 $\tx$ 的内在成本（定义见 \ref{def:g0}）。
%The gas available for the proceeding computation is $g\eqdef \tx_g-g_0$, where $g_0$ is the intrinsic cost of $\tx$ as in (\ref{def:g0}). 

我们定义一个包含执行后临时状态 $\st^{P}$ ，剩余燃料 $g$，累计子状态 $A$，和状态代码 $z$ 的多元组：
%We define the tuple of post-execution provisional state $\st^{P}$, remaining gas $g$, accrued substate $A$ and status code $z$:
\begin{align}\label{def:transform}
	(\st^{P},g',A,z)\eqdef
	\begin{cases}
		\creation(\st^0,\sender{\tx},\sender{\tx},\emptystring, \mathsf{ColOwner}(\st,\tx),g,\tx_p,\tx_v,\tx_{\bf i},0,\zeta,\top) &  \tx_a=\varnothing \\
		\execution(\st^0,\sender{\tx},\sender{\tx},\tx_a,\emptystring,\mathsf{ColOwner}(\st,\tx),\tx_a,g,\tx_p,\tx_v,\tx_v,\tx_{\bf d},0,\top) & \tx_a\neq\varnothing
	\end{cases}
\end{align}
%
需要注意的是，与以太坊相比我们多了三个参数。
%Notice that we have three more parameters compared with Ethereum. 

函数 $\creation$ 和 $\execution$ 的规范分别在第 \ref{sec:creation} 节和第 \ref{sec:execution} 节有所说明。
%The specifications of function $\creation$ and $\execution$ are given in Section~\ref{sec:creation} and Section~\ref{sec:execution} respectively.

\subsubsection{后处理}\label{sec:tx_post_process}
%\subsubsection{Postprocessing}\label{sec:tx_post_process}

\paragraph{存储抵押退款及收费}
%\paragraph{Storage collateral refund and charge.}

在处理消息调用或合约创建请求后，Conflux 检查增加的存储是否超过 $\tx_\ell$ 中所规定的存储上限，以及存储项所有者是否有足够余额支付存储抵押。
%After the message call or contract creation is processed, Conflux checks whether the incremental storage exceeds storage limit specified in $\tx_\ell$ and if the storage owner has enough balance for storage collateral. 
我们用 $i\eqdef \mathsf{ColOwner}(\st,\tx)$ 表示修改后存储项的所有者地址，并用 $v$ 表示可用于支付存储抵押的余额，其定义如下：
%Let $i\eqdef \mathsf{ColOwner}(\st,\tx)$ be the address who owns modified storage entries and $v$ be the available balance to pay for storage collateral, which is defined as 
\begin{align}
	v \eqdef \begin{cases}
		\st^{P}[\sender{\tx}]_b & \text{if }\mathsf{ColSpr}(\st,\tx)=\false \\
		\st^{P}[\tx_a]_p[{\sf col}]_b &  \text{if }\mathsf{ColSpr}(\st,\tx)=\true
	\end{cases}
\end{align}
%
需要注意的是，$A_{\bf c}[i]$ 是在执行过程中增加的存储抵押。
%Notice that $A_{\bf c}[i]$ is the incremental storage collateral during execution.
若 $A_{\bf c}[i]>\min\{v,\tx_\ell\times 10^{18}/1024\}$，执行将因为抵押余额不足或超出存储上限而失败，
%If $A_{\bf c}[i]>\min\{v,\tx_\ell\times 10^{18}/1024\}$, then the execution fails because of not enough balance for collateral or exceeding the storage limit, 
且所有经过修改的状态将被恢复至 $\st^0$，即 $\st'\eqdef\st^0$。
%and all the modified state will be reverted to $\st^0$, i.e. $\st'\eqdef\st^0$. 
我们用 $R'$ 表示上一笔交易的收据，则此情况下当前交易 $\tx$ 的收据为
%Let $R'$ denote the receipt of last transaction. Then the receipt of current transaction $\tx$ will be 
\begin{align}
	&R_u=R'_u+\tx_g && R_f = \tx_g\times\tx_p && R_g = \mathsf{GasSpr}(\st,\tx) && R_{\bf l}=\emptystring \\
	&R_z=1 && R_s = \mathsf{ColSpr}(\st,\tx) && R_{\bf o}=\emptystring && R_{\bf i}=\emptystring
\end{align}

否则，\name 收取并在后续退还存储抵押，将世界状态 $\st^P$ 转化为 $\st^*$/
%Otherwise \name charges and refunds storage collateral and transforms world-state $\st^P$ into $\st^*$. 
我们在此略过边执行边自毁合约，因为其存储抵押在自毁过程中已被退还。
%We skim the self-destructed contracts here because their storage collateral have been refunded during self-destruction. 
此时，账户状态中的存储抵押也将被更新。
%The storage collateral in account state is also updated at this time. 

\begin{align}
	&\st^1  \eqdef \st^{P} \qquad \mbox{  except:}\\
	&\forall a \in \B_{160} \text{ with }  A_{\bf c}[a]\neq 0, \\
	&\quad \begin{cases}
	\st^1[a]_p[{\sf col}]_b \eqdef \st^{P}[a]_p[{\sf col}]_b + f(a) & \mbox{if $a$ refers to a contract account, i.e. $\mathsf{Type}_{a}=\typecontract$} \\
	\st^1[a]_b \eqdef \st^{P}[a]_b + f(a) & \mbox{if $a$ refers to a normal account, i.e. $\mathsf{Type}_{a}= \typenormal$}
	\end{cases}\\
	& \st^1[a]_o \eqdef \st^P[a]_o - f(a)\\ 
	&\st^1[a_{\sf stake}]_{\bf s}[k_3] \eqdef \st^P[a_{\sf stake}]_{\bf s}[k_3] + \sum_{a\in \B_{160}}(f(a) + A_{\bf c}[a]) \\
	&\st^1[a_{\sf stake}]_{\bf s}[k_4] \eqdef \st^P[a_{\sf stake}]_{\bf s}[k_4] + \sum_{a\in \B_{160}}A_{\bf c}[a] \\
	&\mbox{where:}  \\
	&a_{\sf stake} \eqdef \stakingcontract \\ 
	&k_3 \eqdef {\sf [total\char`_issued\char`_tokens]_{\sf ch}}  \\ 
	&k_4 \eqdef {\sf [total\char`_storage\char`_tokens]_{\sf ch}}  \\ 
	& f(a) \eqdef \min\{-A_{\bf c}[a], \st^P_o[a]\}
\end{align}

\paragraph{燃料费退款}
%\paragraph{Gas fee refund.}

\emph{可退还燃料量} $g^{\dagger}$ 是以下两个中更小的值：$\tx$ \textbf{燃料量} 的四分之一和 \emph{合理剩余燃料} $g'$。即，$g^{\dagger}\eqdef \min\set{g', \tx_g/4}$。
%The \emph{refundable amount of gas} $g^{\dagger}$ is the minimum of the \emph{legitimately remaining gas} $g'$ (as calculated in (\ref{def:transform})) and a quarter of the \textbf{gasLimit} of $\tx$, i.e. $g^{\dagger}\eqdef \min\set{g', \tx_g/4}$.
燃料费退款作用于世界状态 $\st^{*}$，并使 $\st'\eqdef \Upsilon(\st,\tx)$。
%The refund of gas fee is applied on world-state $\st^{*}$ and results in $\st'\eqdef \Upsilon(\st,\tx)$.

\begin{align}
	& \st^2  \eqdef \st^1 \qquad \mbox{  except:}\\
	& \quad \begin{cases} 
		\st^2\left[\tx_a\right]_p[{\sf gas}]_b \eqdef \st^1\left[\tx_a\right]_p[{\sf gas}]_b+g^{\dagger}\times \tx_p 
		& \mbox{if $\mathsf{GasSpr}(\st,\tx)=\true$}\\
		\st^2 \left[\sender{\tx}\right]_b \eqdef \st^1\left[\sender{\tx}\right]_b + g^{\dagger}\times \tx_p 
		& \mbox{if $\mathsf{GasSpr}(\st,\tx)=\false$}
	\end{cases} 
\end{align}

\paragraph{Killed contract processing} 
%\paragraph{Killed contract processing} 

赞助机制和抵押机制为销毁合同带来额外任务。首先，对于所有 killed 合约而言，我们将代码项和存储项的抵押退还给相对应的所有者。
%The sponsor mechanism and collateral mechanism bring additional tasks in contract destruction. First, for all the killed contract, we refund the collateral for code and storage entries to the corresponding owner. 
\begin{align}
& \st^3  \eqdef \st^2 \qquad \mbox{  except:}\\
& \forall a \in A_{\bf s},\; \st^2[a]_{\bf s} \eqdef \varnothing \\
&\forall a \in \B_{160} \text{ with }  A^*_{\bf c}[a]\neq 0, \\
&\quad \begin{cases}
\st^3[a]_p[{\sf col}]_b \eqdef \st^2[a]_p[{\sf col}]_b + f(a) & \mbox{if $a$ refers to a contract account, i.e. $\mathsf{Type}_{a}=\typecontract$} \\
\st^3[a]_b \eqdef \st^2[a]_b + f(a) & \mbox{if $a$ refers to a normal account, i.e. $\mathsf{Type}_{a}= \typenormal$}
\end{cases}\\
& \st^3[a]_o \eqdef \st^2[a]_o - f(a)\\ 
&\st^3[a_{\sf stake}]_{\bf s}[k_3] \eqdef \st^2[a_{\sf stake}]_{\bf s}[k_3] + \sum_{a\in \B_{160}}(f(a) + A^*_{\bf c}[a]) \\
&\st^3[a_{\sf stake}]_{\bf s}[k_4] \eqdef \st^2[a_{\sf stake}]_{\bf s}[k_4] + \sum_{a\in \B_{160}}A^*_{\bf c}[a] \\
& A' \eqdef A \Cup A^* \\ 
&\mbox{where:}  \\
&a_{\sf stake} \eqdef \stakingcontract \\ 
&k_3 \eqdef {\sf [total\char`_issued\char`_tokens]_{\sf ch}}  \\ 
&k_4 \eqdef {\sf [total\char`_storage\char`_tokens]_{\sf ch}}  \\ 
& f(a) \eqdef \min\{-A^*_{\bf c}[a], \st^2_o[a]\} \\
& A^* \eqdef A^0 \qquad \mbox{  except:}\\
& \forall a \in \B^{160}, A^*[a]_{\bf c} = - \collateralperbyte \times \sum_{a'\in A_{\bf s}}\left(\mathbb{I}(\st^2[a']_{w}=a) \times |\st^2[a']_{\bf p}| + \sum_{k\in \B_*} \mathbb{I}(\st^2[a']_{\bf s}[k]_o=a)\times 64\right) 
\end{align}

接着，我们退回所有killed合约的资助余额。
%Then we refund the sponsor balance for all the killed contract. 
%
\begin{align}
&\st^4  \eqdef \st^3 \qquad \mbox{  except:}\\
&\forall a \in \B_{160},\;  \st^4[a]_b\eqdef \st^3[a]_b + \sum_{a'\in A_{\bf s}} \left(\mathbb{I}(\st^3[a']_p[{\sf col}]_a=a)\times \st^3[a']_p[{\sf col}]_b + \mathbb{I}(\st^3[a']_p[{\sf gas}]_a=a)\times \st^3[a']_p[{\sf gas}]_b \right)\\
&\forall a' \in A_{\bf s},\; \st^4[a']_p[{\sf col}]_b\eqdef 0 \\
&\forall a' \in A_{\bf s},\; \st^4[a']_p[{\sf gas}]_b\eqdef 0
\end{align}

接着，我们删除所有合约并焚毁剩余余额。
%Then we delete all the contracts and burn all the rest balance 
%
\begin{align}
&\st' \eqdef \st^4 \qquad \mbox{  except:} \\ 
&\forall a \in A_{\bf s}, \st'[a] = \varnothing \\ 
&\st'[a_{\sf stake}]_{\bf s}[k_3] \eqdef \st^4[a_{\sf stake}]_{\bf s}[k_3] - \sum_{a\in A_{\bf s}} (\st[a]_b + \st[a]_t) \\
&\mbox{where:}  \\
&a_{\sf stake} \eqdef \stakingcontract \\ 
&k_3 \eqdef {\sf [total\char`_issued\char`_tokens]_{\sf ch}}  
\end{align}

\paragraph{交易收据} 
%\paragraph{Transaction Receipt.} 

现在交易执行已完成。returning 状态代码 $z$ 代表执行是否成功。
%Now the transaction execution is accomplished. The returning status code $z$ denotes whether the execution succeeds or not. 
假设 $R'$ 为上一笔交易的收据，当前交易的收据如下：
%Supposing that $R'$ is the receipt of last transaction, the receipt of current transaction will be as follows:
\begin{align}
	\begin{array}{llll}
		R_u=R'_u+g' & R_f = (\tx_g-g^{\dagger})\times \tx_p & R_g = \mathsf{GasSpr}(\st,\tx) & R_{\bf l}=A'_{\bf l} \\  
		R_z=z & \multicolumn{3}{l}{R_s = \left\{\begin{array}{ll}
			\mathsf{ColSpr}(\st,\tx) & \text{if }z=0\\
			0 & \text{if }z=1
		\end{array}\right.} \\
		\multicolumn{4}{l}{R_{\bf o}=\mathsf{ToList}\left(\left\{ (a,A'_{\bf c}[a]) | a\in \B_{160}\;\wedge\; A_{\bf c}[a]>0 \right\}\right)}\\
		\multicolumn{4}{l}{R_{\bf i}=\mathsf{ToList}\left(\left\{(a,-A'_{\bf c}[a]) | a\in \B_{160}\;\wedge\; A_{\bf c}[a]<0  \right\}\right)}
	\end{array}
\end{align}
