% !TEX root = ./tech-specification.tex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{消息调用}\label{sec:execution}
%\subsection{Message Call}\label{sec:execution}
当执行一个消息调用时，我们使用下列参数：
%The following intrinsic parameters are used when executing a message call:
\begin{itemize}[nosep]
	\item 世界状态 ${\st}$;
	%\item world-state ${\st}$;
	
	\item 发送方 $s$;
	%\item sender $s$;

	\item 原发送方 $o$;
	%\item original sender $o$;

	\item 接受方 $r$;
	%\item recipient $r$;
	
	\item 调用栈中其他参与方 ${\bf t}$
	%\item other recipients in call stack ${\bf t}$
	
	\item 存储所有者 $i$
	%\item storage owner $i$

	\item 代码将被执行的账户 $c$, 通常即接收方; 
	%\item the account $c$ whose code is to be executed, usually the same as recipient; 

	\item 可用燃料 $g$;
	%\item available gas $g$;

	\item 燃料价格 $p$;
	%\item gas price $p$;

	\item 金额 $v$;
	%\item value $v$;

	\item 调用中的输入信息 $\vec{d}$，即一个任意长度字节数组；
	%\item input data $\vec{d}$ of the call, as an arbitrary length byte array;

	\item 消息调用栈/合约创建栈的当前深度 $e$；
	%\item the present depth of message-call/contraction-creation stack $e$;

	\item 以及，改变世界状态的许可 $w$。
	%\item and finally the permission to change the state $w$.
\end{itemize}

执行消息调用时，世界状态和交易子状态可能发生改变，而在执行结尾系统将生成一个输出信息数组 $\vec{o}$。
%During the execution of message calls, the state and transaction substate may change, and finally an output data array $\vec{o}$ will be generated.
当执行（由外部控制者生成的）交易时，输出信息 $\vec{o}$ 将被忽视。
%In case of executing transactions (generated by external controllers) the output data $\vec{o}$ is ignored, 
但是，（由内部执行生成的）消息调用可能因执行 VM 代码而进一步改变状态，特别是在另一个消息调用或交易执行过程中生成的消息调用。
%however message calls (generated by internal execution process) can result further consequences due to the execution of VM-codes, especially when the message call is generated inside the execution of another message call (or transaction).
\begin{align}
  	\left(\st', g', A, z, \vec{o} \right) \eqdef \execution\left(\st,s,o,r,\vec{t},i,c,g, p,v,\tilde{v},\vec{d},e,w \right)
\end{align}  
需要注意的是，为了 $\op{DELEGATECALL}$ 指令，我们区别待转账的金额 $v$，和出现在执行上下文中的金额  $\tilde{v}$。
%Note that we differentiate between the value to be transferred, $v$, from the value apparent in the execution context, $\tilde{v}$, for the $\op{DELEGATECALL}$ instruction.

我们用 $\st^*$ 表示第一个过渡世界状态。（若 $s\ne r$，则）除了由发送方 $s$ 转账给接收方 $r$ 的金额外，该状态与原先世界状态完全一致。
%We let $\st^*$ denote the first transitional world-state, which is the same as the original state except for the value transferred from sender $s$ to recipient $r$ (if $s\ne r$):
\begin{align}
	\st^*[r]_b\eqdef \st[r]_b+v \qquad \land  \qquad\st^*[s]_b\eqdef \st[s]_b-v
	\label{state:first transitional}
\end{align}
特别的，若在 $\st$ 中 $\st[r]$ 未被定义， \name 将当其为一个地址为 $r$ 的空账户。该账户没有代码或状态，余额和序列号为零。
%In particular, if $\st[r]$ was undefined in $\st$, \name will treat it as an empty account with address $r$ which has no code or state and zero balance and nonce.
在此基础上，若转账金额 $v$ 为正，系统将创建该账户并将其存储在 $\st^*[r]$ 中。因此，先前的等式意味着
%If furthermore the transferred value $v$ is positive, the account will be created and stored in $\st^*[r]$. Thus the previous equation should be taken to mean:
\begin{align}
	\st^* &\eqdef \st \qquad \mbox{except:}\\
	\st^*\left[ s \right] &\eqdef \begin{cases}
		\varnothing & \mbox{if $\st[s]=\varnothing$ $\land$ $v=0$}\\
		\st[s]\quad\mbox{except:}\st^*[s]_b=\st[s]_b-v & \mbox{otherwise}
	\end{cases}\\
% \end{align}
% \begin{align}
	% \mbox{and}\qquad \st'_1 &\eqdef \st \qquad \mbox{except:}\\
	\st^*[r] &\eqdef \begin{cases}
		\account^0 \quad\text{except:}\; \st^*[r]_b=v  & \mbox{if $\st[r]=\varnothing \;\land\; v\ne 0$}\\
		\varnothing & \mbox{if $\st[r]=\varnothing \;\land\; v = 0$}\\
		\st[r]\quad\mbox{except:}\st^*[r]_b=\st[r]_b+v\; & \mbox{otherwise}
	\end{cases}
\end{align}

与接收方相关的 Keccak 哈希为 $\st[c]_c$ 的代码 $\vec{b}$ 将根据模型执行。
%The recipient's associated code $\vec{b}$, whose Keccak hash is $\st[c]_c$, is executed according to the execution model.
需注意的是，代码 $\vec{b}$ 被存储在账户 $c$ 的代码组成部分 $\st[c]_{code}$ 中。
%Note that the code $\vec{b}$ is stored in code component $\st[c]_{code}$ of account $c$.

与合约创建类似，若执行过程因为例外而停止，则世界状态将被恢复为消息调用余额转账前的世界状态（即 $\st$），但不对燃料进行退款。
%Similar as with contract creation, if the execution halts due to an exception, then the state is reverted to the point immediately prior to balance transfer (i.e. $\st$) of the message call but no gas is refunded.
执行该消息调用后的新世界状态 $\st'$ 如下：
%The new state $\st'$ after executing this message call is as follows:
\begin{align}
	\st' &\eqdef 
	\begin{cases}
		\st 	 	& \mbox{if $\st^{**}=\varnothing$}\\
		\st^{**} 	& \mbox{otherwise}
	\end{cases}\\
	g' & \eqdef 
	\begin{cases}
		0 & \mbox{if $\st^{**} =\varnothing$ $\land$ $\vec{o}=\varnothing$}\\
		g^{**} & \mbox{otherwise}	
	\end{cases}\\
	z &\eqdef 
	\begin{cases}
		1	 	& \mbox{if $\st^{**}=\varnothing$}\\
		0	 	& \mbox{otherwise}
	\end{cases}
\end{align}
其中，消息调用产生的状态 $\st^{**}$，剩余可用燃料 $g^{**}$，累计子状态 $A$，和输出信息 $\vec{o}$，皆由在状态 $\st^*$ 上执行的代码执行函数 $\execute$ 决定。
%where the resultant state $\st^{**}$ and available gas remaining $g^{**}$, together with the accrued substate $A$ and the output data $\vec{o}$, 
%are determined by the code execution function $\execute$ evaluated on state $\st^*$.
\begin{align}
	\left(\st^{**}, g^{**},  A, \vec{o} \right) \eqdef \execute \left(\st^*, g, I  \right)
\end{align}
其中 $I$ 包含如下执行环境参数：
%where $I$ contains the parameters of the execution environment as follows:
\begin{align}
	I_a &\eqdef r\\
	I_o &\eqdef o\\
	I_i &\eqdef i\\
	I_p &\eqdef p\\
	I_\vec{d} &\eqdef \vec{d}\\
	I_\vec{t} &\eqdef \vec{t}\\
	I_s &\eqdef s\\
	I_v &\eqdef \tilde{v}\\
	I_\vec{b} &\eqdef \vec{b}\\
	I_{\head} & \eqdef \head \\
	I_{\mathbf{L}} & \eqdef \mathbf{L}\\ 
	I_e &\eqdef e\\
	I_w &\eqdef w	% I_\vec{b} \;\; &\text{such that }  \kec\left(I_\vec{b}\right)  = \st[r]_c
\end{align}



为例如椭圆曲线公钥恢复、 SHA2-$256$ 哈希方案等等的常用功能，我们设置了八个有着保留代码地址 $c\in\set{1,2,\dots,8}$ （带有类型标志 $\typereserved$）的``预编译计算合约''
%For the frequently used functionalities such as the elliptic curve public key recovery, the SHA2-$256$ hash scheme, and so on, we set up eight ``precompiled computation contracts'' with reserved code's address $c\in\set{1,2,\dots,8}$ (with type indicator $\typereserved$). 
预编译计算合约在执行过程中没有副作用。它们将不生成日志，修改账户的存储，或触发另一个消息调用。
%The precompiled computation contracts have no side-effect during execution. They will not generate logs, modify accounts' storage or trigger another message call. 
%
在 \name 的当前实现里，这些特别合约在以太坊的最新版本中有所明确 \cite{ETH_yellow}。
%In the present implementation of \name these exceptional contracts are specified as in the latest version of Ethereum \cite{ETH_yellow}.

\name 也为特别原因启用内部合约。对内部合约的高层设计描述在第 \ref{sec:internal} 节中有所阐述。
%\name also introduces internal contracts for specific usage. A high-level description for the internal contracts is given in Section~\ref{sec:internal}. 
当接收方地址 $r$ 为内部合约之一时，Conflux 将处理 $\execute_{\sf internal}(\st^*,g,I)$，并返回 $\left(\st^{**}, g^{**},  A, \vec{o} \right)$。正式定义见第 \ref{sec:internal_contract} 节。
%When the recipient's address $r$ is one of the internal contracts, Conflux processes $\execute_{\sf internal}(\st^*,g,I)$ and returns $\left(\st^{**}, g^{**},  A, \vec{o} \right)$. A formal definition is given in section~\ref{sec:internal_contract}. 

