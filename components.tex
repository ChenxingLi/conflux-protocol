% !TEX root = ./tech-specification.tex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%------------------------------------------------

\section{基本构成}
概括而论，{\name} 的全局状态由其所有账户和账户的相关状态构成，而伴随着每一次交易，全局状态都会产生更新。 
{\name} 区块链的每个区块都存储着该区块已处理的所有交易信息，而区块头内也存储着为区块排序所必要的信息。
在本章节我们将详细讨论账户、交易和区块的定义和意义。


\subsection{账户}
\label{subsec:accounts}

{\name} 的全局状态可被描述为一个账户模型，其中的基本存储元素为一个\emph{账户}。
系统中的每一个成员，即每一个能与 {\name} 全局互动的个人或个体，都拥有一个记录着该用户所有必要信息的账户 $\account$ 。信息通过一个以地址和状态构成的键值组合 $(\account_{addr}, \account_{state})$记录
%。
%原翻译：系统中的每一个成员，也即每一个能与 Conflux 互动的个人或个体，都拥有一个账户 $\account$ 以记录该用户的所有必要信息 —— 一个由地址和状态构成的键值组合 $(\account_{addr}, \account_{state})$。
%
账户地址 $\account_{addr}$ 是一个 160 比特的标识符。
账户状态 $\account_{state}= (\account_{basic},\account_{code}, \account_{storage},\account_{deposit},\account_{vote})$ 由五个部分组成。
%The account state $\account_{state}= (\account_{basic},\account_{code}, \account_{storage},\account_{deposit},\account_{vote})$ consists of five components. 

账户的基本状态 $\account_{state}$， 代码信息 $\account_{code}$，锁仓列表 $\account_{deposit}$，和投票列表 $\account_{vote}$ 是四个 $\rlp$ 结构的有序序列 (比较 \cite{ETH_yellow})。
%The account basic state $\account_{state}$, the code info $\account_{code}$, the deposit list $\account_{deposit}$ and the vote list $\account_{vote}$ are four serialized sequences in an $\rlp$ structure (c.f. \cite{ETH_yellow}). 
账户存储 $\account_{storage}$ 是多个键值组合的集合，该组合将 $256$ 比特的地址映射到一个$\rlp$ 结构的有序存储信息。
%The account storage $\account_{storage}$ is a set of key-value pairs which map 256-bit address to a serialized storage information in an $\rlp$ structure. 
此外，每一个账户都有一对关联的公钥和私钥 $\left(\account_{pubkey}, \account_{prikey}\right)$。
%Furthermore we note that each account $\account$ is associated with a pair of public key and private key $\left(\account_{pubkey}, \account_{prikey}\right)$.
而账户地址由一个 $4$ 比特的类型标志和一个$156$ 比特的关联公钥摘要串联而成：
%即 $\account_{addr} \eqdef \kec \left( \account_{pubkey} \right)[96\dots 255]$。
%The account address is the concatenation of $4$-bit type indicator and a $156$-bit digest of the associated public key: 
\begin{equation}\label{eq:account-address}
	\account_{addr} \eqdef \mathsf{Type}_{\account} \circ \kec \left( \account_{pubkey} \right)[100\dots 255]
\end{equation}
其中 $\mathsf{Type}_{\account}\in \B_4$ 即类型标志，
%where $\mathsf{Type}_{\account}\in \B_4$ is the type indicator,
$\mathsf{Type}_{\account}=\typenormal$ 表示 \emph{普通账户} (即 \emph{非合约账户})，
%which is $\mathsf{Type}_{\account}=\typenormal$ for \emph{normal accounts} (a.k.a. \emph{non-contract accounts}), 
$\mathsf{Type}_{\account}=\typecontract$ 表示 \emph{(Solidity) 合约},
%$\mathsf{Type}_{\account}=\typecontract$ for \emph{(Solidity) contracts},
而 $\mathsf{Type}_{\account}=\typereserved$ 表示 \emph{内置/保留合约} (即 \emph{``预编译合约''})。
%and $\mathsf{Type}_{\account}=\typereserved$ for \emph{built-in/reserved contracts} (a.k.a. \emph{``precompiled contracts''}).


出于简洁性和方便性的考虑，只要不出现歧义，我们将以不加脚标的 $\account$表示账户的状态，并用 $a\eqdef \account_{addr}$ 表示该账户的地址。


\paragraph{基本状态}

一个账户的基本状态 $\account_{basic} \eqdef\left( \account_n, \account_b, \account_c,\account_t, \account_o, \account_r, \account_a, \account_p\right)$ 由以下域组成：
%An account basic state $\account_{basic} \eqdef\left( \account_n, \account_b, \account_c,\account_t, \account_o, \account_r, \account_a, \account_p\right)$ consists of the following fields. 
\begin{itemize}[nosep]
	\item {\bf 序列号(nonce):} 一个正式表达为 $\account_n\in \N_{256}$ 的计数标量，用以记录由账户发起的历史活动数。例如，从 $\account_{addr}$ 发出的所有历史交易的数量。而对于合约账户，序列号表示其所创造的合约数量。
	%\item {\bf nonce:} A scalar counter recording the number of previous activities initiated by this account. Formally denoted by $\account_n\in \N_{256}$. For example, the number of transactions sent from $\account_{addr}$, or the number of contract-creations in the case this account is associated with codes.
	%原翻译：一个计数标量，由 $\account_n$ 表示。“nonce”（现时）记录一个账户的历史活动数量，例如历史上从 $\account_{addr}$ 发出的所有交易的数量。对于合约账户，现时表示其所创造的合约数量。

	\item {\bf 余额(balance):} 一个等于该账户所拥有的 \unit 余额的标量，正式记作 $\account_b\in \N_{256}$。
	%\item {\bf balance:} A scalar value equal to the number of \unit  owned by this account. Formally denoted by $\account_b\in \N_{256}$. 

	\item {\bf 代码哈希(codeHash):} 每当 $\account_{addr}$ 收到一个消息调用时会被执行 EVM 代码的哈希值。不同于其他域，代码哈希一旦产生就不可更改。所有的这类代码片段被储存在一个状态数据库里，以便今后调用。当所存储的代码是 $\mathbf{p}$ 时，被记为 $\account_c\in \B_{256}$ 的该哈希需满足 $\account_c=\kec\left(\mathbf{p} \right)$。  
	%原翻译：\item {\bf codeHash:} 每当 $\account_{addr}$ 收到一个消息调用时会被执行 EVM 代码的哈希值。不同于其他域，codeHash 一旦产生就不可更改。所有的这类代码片段被储存在一个状态数据库里，以便今后调用。该哈希记作 $\account_c$，当所存储的代码是 $\mathbf{p}$ 时 $\account_c$ 需满足 $\account_c=\kec\left(\mathbf{p} \right)$

	\item {\bf Staking 余额(stakingBalance):} 一个正式表达为 $\account_t\in \N_{256}$ 的标量，与用于 staking 的 \unit 数量相等。（详见第 \ref{sec:staking} 节）
	%\item {\bf stakingBalance:} A scalar value equal to the number of staked \unit. Formally denoted by $\account_t\in \N_{256}$. (See section~\ref{sec:staking} for details)

	\item {\bf 存储押金(storageCollateral):} 一个正式表达为 $\account_o\in \N_{256}$ 的标量，其值为存储抵押的 \unit 数量。存储被释放后，其对应的存储抵押将被归还至账户余额。（详见第 \ref{sec:collateral} 节）
	%\item {\bf storageCollateral:} A scalar value equal to the number of \unit used as collateral for storage, which will be returned to balance if the corresponding storage is released. Formally denoted by $\account_o\in \N_{256}$. (See section~\ref{sec:collateral} for details)

	\item {\bf 累计利息收益(accumulatedInterestReturn):} 一个正式表达为 $\account_r\in \N_{256}$ 的标量，其值等于累计利息收益的 \unit 数量。（详见第 \ref{sec:collateral} 节）
	%\item {\bf accumulatedInterestReturn:} A scalar value equal to the number of \unit in accumulated interest return. Formally denoted by $\account_r\in \N_{256}$. (See section~\ref{sec:staking} for details)

	\item {\bf 管理账户(admin):} 若账户 $\account$ 是一个合约，此项为管理员地址。其正式表达为 $\account_a\in \B_{160}$。（详见第 \ref{sec:admin} 节）
	%\item {\bf admin:} The address of the administrator if $\account$ is a contract.  Formally denoted by $\account_a\in \B_{160}$. (See section~\ref{sec:admin} for details)

	\item {\bf 资助信息(sponsorInfo):} 若账户 $\account$ 是一个合约，此项为资助人信息。其包含五个部分： $\account_p[{\sf gas}]_a$ 表示 {\bf 燃料资助人}, $\account_p[{\sf col}]_a$ 表示 {\bf 存储抵押资助人}, $\account_p[{\sf limit}]_a$ 表示 {\bf 燃料资助上限}, $\account_p[{\sf gas}]_b$ 表示 {\bf 燃料资助余额}, $\account_p[{\sf col}]_b$ 表示 {\bf 存储抵押资助余额}。
	其正式表达为 $\account_p\in (\B_{160})^2\times (\N_{256})^3$ 。(详见第 \ref{sec:sponsor} 节)
	%\item {\bf sponsorInfo:} The sponsor information if $\account$ is a contract. It contains five components: {\bf sponsor for gas}, {\bf sponsor for collateral},  {\bf sponsor gas limit}, {\bf sponsor balance for gas} and {\bf sponsor balance for collateral}. Formally denoted by $\account_p\in (\B_{160})^2\times (\N_{256})^3$. (See section~\ref{sec:sponsor} for details). We use $\account_p[{\sf gas}]_a$, $\account_p[{\sf col}]_a$, $\account_p[{\sf limit}]_a$, $\account_p[{\sf gas}]_b$ and $\account_p[{\sf col}]_b$ to reference these five components. 
\end{itemize}

\paragraph{存储状态}

若一个账户为合约账户，其存储状态 $\account_{storage}$ （或缩写为 $\account_{s}$ ）由一个键值数据库代表。
%An account's storage state $\account_{storage}$ (or as $\account_{s}$ for abbreviation)is a key/value database representing the account's storage state, if $\account$ is a contract account. 
所有存储项以一个 $256$ 比特或 $320$ 比特的字符串 $k\in \B_{256}\cup \B_{320}$ 为键。其表达式为 $(v,o)\in \N_{256}\times \B_{160}$ 。
此处 $v$ 表示该项存储值，而 $o$ 表示为该项提供存储抵押的所有者。(更多有关存储抵押的细节详见第 \ref{sec:collateral} 节)
%Every storage entry is keyed by a 256-bit string or a 320-bit string $k\in \B_{256}\cup \B_{320}$ and is represented as $(v,o)\in \N_{256}\times \B_{160}$, where $v$ denotes the value stored in this entry and $o$ denotes the owner who provides storage collateral for this entry. (See section~\ref{sec:collateral} for details about storage collateral.)
我们用 $\account_{\bf s}[k]$ 代表以 $k$ 为键的存储项 $(v,o)$ ，并用 $\account_{\bf s}[k]_v$ 和 $\account_{\bf s}[k]_o$ 代表所对应的域。
%We use $\account_{\bf s}[k]$ to represent storage entry $(v,o)$ keyed by $k$ and use $\account_{\bf s}[k]_v$ and $\account_{\bf s}[k]_o$ to denote corresponding fields. 
若存储状态不包含以 $k$ 为键的存储项，我们用 $\account_{\bf s}[k]=\varnothing$ 表示以上情况。
%We denote by $\account_{\bf s}[k]=\varnothing$ for the case the storage state doesn't contain an entry with key $k$. 


% Since we have contract address conflict exception, we no longer need these functions.
% Given a world-state $\st$, an account is \emph{empty} in this state if it has zero nonce, zero balance, and no code.
% \begin{align}
% 	\mathsf{EMPTY}(\st,a) \eqdef \left[ \st[a]_c = \kec\big(()\big) \;\land\; \st[a]_n=0 \;\land \;\st[a]_b=0\right]
% \end{align}
% An account is \emph{dead} if its account state is non-existent or empty.
% \begin{align}
% 	\mathsf{DEAD}(\st, a) \eqdef \left[ \st[a]=\varnothing \;\lor\;\mathsf{EMPTY}(\st,a)\right]
% \end{align}

% We also define the account validity function $v$ as follows:
% \begin{align}
% 	v(\account)\eqdef 
% 	\left[ \account_n \in 
% 	\N_{256} \land \account_b\in \N_{256} \land \account_s\in \B_{256} \land \account_c\in\B_{256}\right]
% \end{align}
% For every legal world-state $\st$ and for every address $a\in\B_{160}$, 
% % there is either $\st[a]=\varnothing$ or $v\left(\st[a]\right)=1$.
% the account with address $a$ is either unused or valid, i.e.
% \begin{align}
% 	\forall a\in\B_{160}: \left(\st[a] = \varnothing \right) \lor \left(  v\left(\st[a]\right)\right)
% \end{align}

% Thus we define the \emph{world-state collapse function} $L_S$ that translates the world-state $\st$ into account states:
% \begin{align}
% 	L_S(\st) \eqdef \set{ \big(a, \rlp(\st[a]_n, \st[a]_b, \st[a]_s, \st[a]_c) \big) \;\big|\; a\in\B_{160}
% 	\land \st[a]\ne \varnothing}
% \end{align}

% This function $L_S$ and the trie function $\trie$ are used in conjunction to provide a short hash digest of the {\name} world-state.

\paragraph{代码信息}

对一个合约账户 $\account$ 而言，其代码部分 $\account_{code}\eqdef (\account_{\bf p},\account_{w})$ 包含账户代码 $\account_{\bf p}\in \Byte^*$ 和支付了代码存储抵押的地址 $\account_{w}\in \B_{160}$。
%For a contract account $\account$, its code information $\account_{code}\eqdef (\account_{\bf p},\account_{w})$ stores the account code $\account_{\bf p}\in \Byte^*$ and the address $\account_{w}\in \B_{160}$ who paid the code storage collateral.

\paragraph{ Staking 投票信息}
%\paragraph{Staking vote info}

一个账户的 staking 投票列表 $\account_{vote}$ 或缩写为 $\account_{v}$ ）是一个键值对的集合，代表着所给区块号码解锁的投票staking信息。
%An account's staking vote list $\account_{vote}$ (or as $\account_{v}$ for abvbreviation)is a key/value set representing the vote staking info unlock at given block number. 
每一条的键是 $i\in\N_{64}$，以 $\unit$ 为单位存储着 staking 投票数 $s\in \N_{256}$。
%Each entry is keyed by a block ordering index $i\in\N_{64}$ stores the staking vote amount $s\in \N_{256}$ in $\unit$. 
它代表着，账户承诺在序号为 $i$ 的区块前至少锁定 $s\;\unit$。更多详见第 \ref{sec:staking} 节。
%It means that the account promises to lock at least $s\;\unit$ before block with order index $i$. See section~\ref{sec:staking} for more details.

\paragraph{锁仓列表}
%\paragraph{Deposit list}

一个账户的锁仓列表 $\account_{deposit}\in (\N_{256}\times \N_{64}\times \N_{256})^*$ 由一系列的锁仓项组成。
%An account's deposit list $\account_{deposit}\in (\N_{256}\times \N_{64}\times \N_{256})^*$ is a series of deposit item. 
而每一个锁仓项包含一些锁仓代币。锁仓项是由代币数量（以 \unit 为单位），锁仓时间（以区块全部数量为衡量标准），和累计利润率构成的三元组。
%Each entry is a handful of deposited tokens in a ternary tuple of its amount (in \unit), its deposit time (measured in the total number of blocks) and its accumulated interest rate. 
我们使用 $\account_{deposit}[{\sf amt}],\account_{deposit}[{\sf idx}],\account_{deposit}[{\sf accIR}]$ 代表这三个组成部分。更多细节详见第 \ref{sec:staking} 节。
%We use $\account_{deposit}[{\sf amt}],\account_{deposit}[{\sf idx}],\account_{deposit}[{\sf accIR}]$ refers the three compoments. See section~\ref{sec:staking} for more details.
$\\$

在各个部分的初始化阶段，Conflux 将所有比特值、字节值和整数值设为零，并将任意长度序列设为空集。作为例外，代码哈希将被设为空字符串的哈希值。因此，账户状态各组成部分的初始值如下
%In initialization of each component, Conflux sets all the bit values, byte values and integers to zero and sets arbitrary length series to empty set, except the code hash which is set to the hash value of empty string. So each account state component is initialized as follows
\begin{align}
	\account^0_{basic} &\eqdef (0,0,\kec(\emptystring),0,0,0,0,(0,0,0,0,0)) \\
	\account^0_{basic\_smp} &\eqdef (0,0,0,0,0) \\
	\account^0_{code} &\eqdef (\varepsilon,0) \\
	\account^0_{storage} &\eqdef \varepsilon \\
	\account^0_{vote} &\eqdef \varepsilon \\
	\account^0_{deposit} &\eqdef \varepsilon \\
	\account^0 & \eqdef (\account^0_{basic},\account^0_{code},\account^0_{storage},\account^0_{vote},\account^0_{deposit})\label{eq:default_account}
\end{align}

%
对应于 {\name} 世界状态 $\st$ 和地址 $a\in\B_{160}$，我们用 $\st [a]$ 表示拥有地址 $a=\account_{addr}$ 的账户 $\account$ 的状态 $\account_{state}$，换言之 $\st [a] \eqdef \account_{state}$。
%Given the {\name} world-state $\st$ and an address $a\in\B_{160}$, we denote by $\st [a]$ for the state $\account_{state}$ of the account $\account$ with address $a=\account_{addr}$, i.e. $\st [a] \eqdef \account_{state}$.
% \left(\account_n, \account_b, \account_s, \account_c \right)$.
我们使用 $\st[a]\eqdef \varnothing$ 来表示地址为 $a$ 的账户未被初始化过。
%We denote by $\st[a]\eqdef \varnothing$ if the account with address $a$ is never initialized. 
%
同时，我们以 $\st[a]_{\bf s}$ 表示存储部分 $\account_{storage}$，以 $\st[a]_{\bf v}$ 表示 staking 投票部分 $\st[a]_{vote}$。
%Also, we denote by $\st[a]_{\bf s}$ for storage component $\account_{storage}$ and $\st[a]_{\bf v}$ for staking vote component $\st[a]_{vote}$. 

世界状态 $\st$ 从不存储等于初始值 $\account^0$ 的账户状态 $\account_{state}$。
%The world-state $\st$ never stores the account state $\account_{state}$ equals to initialization value $\account^0$. 
因此，$\st[a]\eqdef \varnothing$ 等同于 $\st[a]\eqdef \account^0$。
%So $\st[a]\eqdef \varnothing$ is equivalent to $\st[a]\eqdef \account^0$. 
对于键值结构部分 $\account_{\bf s}$ 和 $\account_{\bf v}$， 我们也无差别地使用 $\varnothing$ 的表达和零初始值。
%For the key value structure components $\account_{\bf s}$ and $\account_{\bf v}$, we also use the notation $\varnothing$ and zero initialization value indistinguishably.

\subsection{世界状态的哈希摘要}
%\subsection{Hash Digest of World-State}

\subsubsection{状态项}
%\subsubsection{State entries}

Conflux 将各账户的各组成部分以 $(k,v)\in \B^*\times \B^*$ 格式分别编码。
%Conflux encodes each component of each account in format of $(k,v)\in \B^*\times \B^*$ respectively. 

\paragraph{基本项} 基本项包含基本组成部分 $\account_{basic}$。对于一个非合约地址，Conflux 不存储只与合约相关的域，例如代码哈希 $\account_c$，管理账户 $\account_a$，和资助信息 $\account_p$。
%\paragraph{Basic entry.} The basic entry stores basic components $\account_{basic}$. Specially, for a non-contract address, Conflux doesn't stores the fields only related to contract, like code hash $\account_c$, contract admin $\account_a$ and sponsor info $\account_p$. 
我们用 $\account_{basic\_smp}\eqdef (\account_n, \account_b, \account_t, \account_o, \account_r)$ 表示普通地址包含的基本组成部分。正式表达为
%Let $\account_{basic\_smp}\eqdef (\account_n, \account_b, \account_t, \account_o, \account_r)$ denote the basic component with only the fields in a normal address. Formally
\begin{align}
	&k\eqdef \alpha_{addr}\\
	&v\eqdef \left\{\begin{array}{ll}
		\rlp(\account_{basic}) & \mathsf{Type}_\alpha=[1000]_2 \\
		\rlp(\account_{basic\_smp}) & \mathsf{otherwise}
	\end{array}\right.
\end{align}
	
	

\paragraph{存储项} 存储项包含 $\account_{\bf s}$ 的所有存储。拥有地址 $\alpha_{addr}$ 的账户 $\alpha$ 内，对于满足 $\account_{\bf s}[s]_v\neq 0$ 的存储键 $s\in \B_{256}$，我们有
%\paragraph{Storage entry.} The storage entry stores all the storages in $\account_{\bf s}$. Given account $\alpha$ with address $\alpha_{addr}$, for each storage key $s\in \B_{256}$ with $\account_{\bf s}[s]_v\neq 0$, we have 
\begin{align}
	k&\eqdef \alpha_{addr}\cdot [{\sf data}]_{\sf ch}\cdot s \\
	v&\eqdef \left\{ \begin{array}{ll}
		\rlp\left(\account_{\bf s}[s]_v\right) & \alpha_{addr} = \account_{\bf s}[s]_o \\ 
		\rlp\left(\account_{\bf s}[s]_v\right) & \alpha_{addr} = a_{\sf stake} \;\wedge\; k \in \{k_1,k_2,k_3,k_4,k_5\} \\ 
		\rlp\left(\account_{\bf s}[s]\right) & \mbox{otherwise}
	\end{array}\right.\\
	\mbox{where:} &\\
	a_{\sf stake} &\eqdef \stakingcontract \\
	k_1 &\eqdef \sf [accumulate\char`_interest\char`_rate]_{\sf ch} \\ 
	k_2 &\eqdef \sf [interest\char`_rate]_{\sf ch} \\
    k_3 &\eqdef \sf [total\char`_staking\char`_tokens]_{\sf ch} \\
    k_4 &\eqdef \sf [total\char`_storage\char`_tokens]_{\sf ch} \\
    k_5 &\eqdef \sf [total\char`_issued\char`_tokens]_{\sf ch} 
\end{align}

其中，有五个特殊存储项记录了关于 \name 区块链的一些统计信息。这些项没有存储所属者。
%There are five special storage entries storing some statistic information about \name blockchain, which have no storage owner. 

\paragraph{存储根项} 存储根项记录着账户 $\account$ 的存储布局。
%\paragraph{Storage root entry.} The storage root entry stores the storage layout for account $\account$. 
\begin{align}
	&k\eqdef \alpha_{addr}\cdot [{\sf data}]_{\sf ch}\\
	&v\eqdef \emptystring
\end{align}

\paragraph{代码项} 代码项记录着代码信息部分。 $\account_{code}$。 
%\paragraph{Code entry.} The code entry stores the component code info $\account_{code}$. 
\begin{align}
	&k\eqdef \alpha_{addr}\cdot [{\sf code}]_{\sf ch}\cdot \alpha_c  \\
	&v\eqdef \rlp(\account_{code})
\end{align}

\paragraph{ Staking 投票列表项} Staking 投票列表项记录着 staking 投票列表部分 $\account_{vote}$。 
%\paragraph{Staking vote list entry.} The staking vote list entry stores the component staking vote list $\account_{vote}$. 
\begin{align}
	k&\eqdef \alpha_{addr}\cdot [{\sf vote}]_{\sf ch}  \\
	v&\eqdef \rlp(\tolist(\account'_{vote}))\\
	\mbox{where:}&\notag\\ 
	\account'_{vote} &\eqdef \mbox{$\account_{vote}$ removing all the key $x$ with $\account_{vote}[x]=\account_{vote}[x-1]$}
\end{align}

\paragraph{锁仓列表项} 锁仓列表项记录着锁仓列表部分 $\account_{deposit}$。 
%\paragraph{Deposit list entry.} The deposit list entry stores the component deposit list $\account_{deposit}$. 
\begin{align}
	&k\eqdef \alpha_{addr}\cdot [{\sf deposit}]_{\sf ch}  \\
	&v\eqdef \rlp(\account_{deposit})
\end{align}

\subsubsection{多版本 Merkle 前缀树}
%\subsubsection{Multi-version Merkle Patricia Trie}

以太坊将所有键值对汇集入 Merkle 前缀树，并在执行交易时更新它。
%Ethereum collects all the key/value pairs into MPT (Merkle Patricia Trie) and updates it during execution of transactions. 
然而，在一个高吞吐的区块链系统中， Merkle 前缀树可能被高频率地访问，并因此成为系统性能的瓶颈。
%However, in a high throughput blockchain system, the MPT may be accessed in a high frequency and hence become a bottleneck of performance. 
Conflux 维持一个 \textbf{read-through write-back} 缓存，并根据该缓存对 Merkle 前缀树进行周期性的更新。
%Conflux maintains a \textbf{read-through write-back} cache and commits cached changes to MPT periodically. 

正式定义下，Conflux 在任意时刻都维持三个键值集合 $T_0,T_1,T_2$， 分别称作 {\bf 快照集}, {\bf 中间集} 和 {\bf 增量集}。
%Formally, at any time, Conflux maintains three key/value sets $T_0,T_1,T_2$, which are called {\bf snapshot}, {\bf intermediate set} and {\bf delta set} respectively. 
每个集合都是前一个集合的缓存。$T_2$ 是在执行交易时唯一更新的集合。
%The later one is the cache of the former one. $T_2$ is the only one updated during transaction execution. 
为了平衡 Merkle 前缀树 {\bf 增量集} 中的键并达到高性能表现，MPT $T_2$ 使用不同方式计算键。使
%In order to balance the keys in MPT {\bf delta set} and achieve a high performance, MPT $T_2$ has a different way in computing keys. Let 
%
\begin{align}
	&p\eqdef\kec(\trie(T_0),\trie(T_1)) \\
	&f_{addr}(\alpha_{addr},p)\eqdef\kec(p[0..11]\cdot \alpha_{addr})[0..11]\cdot \alpha_{addr} \\ 
	&f_{store}(s,p)\eqdef \kec(p\cdot s)[4..31]\cdot s\\
	&\text{(此处的序号应用在字节级别
		%The index here are applied on byte-level.
		)} \notag
\end{align}

键被定义为（表达符号从先前的段落继承）
%The key is defined as (the symbols are inherited from the previous section)
\begin{itemize}[nosep]
	\item {\bf 基础项}
	%\item {\bf Basic entry.} 
	$k\eqdef f_{addr}(\alpha_{addr},p)$
	\item {\bf 存储项} 
	%\item {\bf Storage entry.} 
	$k\eqdef f_{addr}(\alpha_{addr},p)\cdot [{\sf data}]_{\sf ch}\cdot f_{store}(s,p)$
	\item {\bf 存储根项}
	%\item {\bf Storage root entry.} 
	$k\eqdef f_{addr}(\alpha_{addr},p)\cdot [{\sf data}]_{\sf ch}$
	%\item {\bf Code entry.} 
	\item {\bf 代码项} $k\eqdef f_{addr}(\alpha_{addr},p)\cdot [{\sf code}]_{\sf ch}\cdot \alpha_c$
	%\item {\bf Staking vote list entry.}
	\item {\bf Staking 投票列表项} $k\eqdef f_{addr}(\alpha_{addr},p)\cdot [{\sf vote}]_{\sf ch}$
	%\item {\bf Deposit entry.}
	\item {\bf 锁仓项} $k\eqdef f_{addr}(\alpha_{addr},p)\cdot [{\sf deposit}]_{\sf ch}$
 
\end{itemize}

\paragraph{增量集}
%\paragraph{Delta set.}

若一个状态项在一笔交易执行后被添加、更新或移除，其最新的内容将被添加到增量集。
%After a successful transaction execution, if a state entry is added, updated or removed after execution of one transaction, its newest content will be added to the delta set. 
增量集只比较一笔交易前后的状态项，并不了解执行交易的中间步骤。
%Notice that the delta set only compares the state entry before and after a transaction execution. It is not aware of the intermediate steps during transaction execution. 
%
删除状态项时，一个该项的初始值将被添加到增量集，代表删除操作。
%In case of deleting a state entry, an initialization value for corresponding entry will be added to the delta set representing deletion operation. 

每 $\snapshotperiod$ 个纪元，中间集的 Merkle 前缀树将被合并到快照集的 Merkle 前缀树。
%The intermediate MPT will be merged to snapshot MPT every $\snapshotperiod$ epochs. 
对于整数 $N$，在纪元 $\snapshotperiod\cdot N$ 的执行之后，
%In particular, for some integer $N$, after execution of epoch $\snapshotperiod\cdot N$, 
\footnote{因为 Conflux 延迟 $\deferblk$ 个纪元执行交易， \emph{第 $i$ 个纪元的执行} 意味着第 $i-\deferblk$ 个纪元所包含的交易的执行。 细节详见区块组成部分 {\bf deferredStateRoot}。}
%\footnote{Since Conflux defers the execution of transactions for $\deferblk$ epochs, the \emph{execution of epoch $i$} means the execution for transactions in epoch $i-\deferblk$. See block component {\bf deferredStateRoot} for details.}
且在计算第 $\snapshotperiod\cdot N$ 个纪元的枢轴区块的状态根前，Conflux 将把中间集 $T_1$ 合并至快照集 $T_0$。 
%Conflux will merge intermediate set $T_1$ to snapshot $T_0$ before computing the state root of pivot block on epoch $\snapshotperiod\cdot N$. 
每次中间集的 Merkle 前缀树被合并时，Conflux 设当下的增量集 Merkle 前缀树为新的中间集，并重置增量集为空集。正式定义下，
%Each time the intermediate MPT is merged, Conflux sets current delta MPT as new intermediate set and resets delta set as emptyset. Formally,  
\begin{align}
	T'_0 &\equiv \mathsf{MPTMerge}(T_0,T_1) \\
	T'_1 &\equiv T_2 \\
	T'_2 &\equiv \varnothing
\end{align}
%
其中 $\mathsf{MPTMerge}$ 代表一个更新函数，对象是 $T_0$ 集合中 所有在 $T_1$ 集合中有新版本值的项。特别地，$T_0$ 集合将移除使用初始值的项。
%where $\mathsf{MPTMerge}$ is the function updates the entries in $T_0$ which have a new version value in $T_1$. Specially, for the entries with initialization value, $T_0$ removes them.  


\subsubsection{状态根}
%\subsubsection{State root}

使 $\trie(T^{(i)}_0),\trie(T^{(i)}_1),\trie(T^{(i)}_2)$ 表示在纪元 $i$ 执行后 Merkle 前缀树的根,那么纪元 $i$ 的状态根应为
%Let $\trie(T^{(i)}_0),\trie(T^{(i)}_1),\trie(T^{(i)}_2)$ be the roots of MPT after execution of epoch $i$, then the state root of epoch $i$ should be 
%
$$ StateRoot^{(i)}\eqdef\kec(\rlp(\trie(T^{(i)}_0),\trie(T^{(i)}_1),\trie(T^{(i)}_2))).$$

需要注意的是，Conflux 不将 $StateRoot^{(i)}$ 插入至第 $i$ 纪元的枢轴块区块头中。细节详见后文。
%Notice that Conflux doesn't insert $StateRoot^{(i)}$ to the header of pivot block in epoch $i$, see the following for details. 


\subsection{交易}
%\subsection{Transactions}
\label{sec:tx}

{\name} 的每笔交易 $\tx$ 都是一个由控制 {\name} 账户 $\account$ 的外部角色发起的单次指令。该指令需要账户 $\account$ 对应的私钥 $\account_{prikey}$ 所作的密码学签名授权。
%A {\name} transaction $\tx$ is a single instruction composed by an external actor with a {\name} account $\account$, and this instruction is cryptographically signed under the associated private key $\account_{prikey}$ of the sending account $\account$.
鉴权密钥，即交易发起方账户所对应的公钥 $\account_{pubkey}$，也被包含在交易中，以帮助验证交易的合法性。
%The authentication key, i.e. the sending account's associated public key $\account_{pubkey}$, is also included in the transaction for verification.

根据不同的“目的地”，交易分为两种：
%There are two types of transactions depending on the ``destinations'': 
\begin{enumerate}[nosep]
	\item {目的地为账户地址：} 这种是普通交易，用以支付货币及/或者调用消息，被称为\emph{行为交易}；
	%\item {to an account address:} these are normal transactions that may transfer value and/or result in message calls, known as \emph{action transactions};

	\item {无目的地：} 这种交易用于创建新合约，被称为 \emph{合约创建交易} 或简称为 \emph{创建交易}。
	%\item {to ``nowhere'':} these transactions are used to create new contracts, known as \emph{contract creation transactions} or simply \emph{creation transactions}.
\end{enumerate}
以上两种交易均包含下列域：
%Both types of transactions share the following common fields:
\begin{itemize} [nosep]
	\item {\bf 序列号(nonce):} 一个标量值，等于之前发起的所有交易的总数，记作 $\tx_n \in\N_{256}$。
	%A scalar value equal to the number of previously sent transactions. Formally denoted by $\tx_n \in\N_{256}$.

	\item {\bf 燃料价格(gasPrice):} 一个标量值，表示执行交易 $\tx$ 时消耗每一单位燃料所需支付的 Drip 数，记作 $\tx_p\in\N_{256}$。
	%\item {\bf gasPrice:} A scalar value indicating the number of \unit to be paid per unit of gas that is consumed as a result of the execution of $\tx$. Formally denoted by $\tx_p\in\N_{256}$.

	\item {\bf 燃料量(gasLimit):} 
	一个标量值，记作 $\tx_g\in\N_{256}$，表示交易发送方愿意为执行交易 $\tx$ 所花费的燃料\emph{总量}。该笔金额将在最开始支付完成，先于其他所有计算之前，并不允许后续追加或退款。交易的发送方负责保证交易的 \emph{燃料连量} 不会过高，以避免不必要的燃料浪费。
	%\item {\bf gasLimit:} A scalar value indicating the \emph{total} amount of gas paid for the cost of the execution of $\tx$. This is paid up-front, before any actual computation is done, and may not be increased or refunded later. 
	%Formally denoted by $\tx_g\in\N_{256}$.
	%It is the transaction sender's responsibility to avoid any extravagance caused by an unnecessarily high {\bf gasLimit}.

	\item {\bf 行动(action):} 
	一个变量大小域，表示此交易接收方所触发的行动，正式记作 $\tx_a$。
	%A variable size field indicating the action of this transaction, formally denoted by $\tx_a$. 
	此参数内含一个子域 {\bf create}，用以标记 $\tx$ 是否为一个创建交易。为了表达的简洁性，我们会使数值暗含该信息。
	%There is a sub-field {\bf create} indicating whether $\tx$ is a contract creation transaction, which we make it implicit for notation convenience. 
	因此，$\tx_a$ 表示接收方的 $160$ 比特地址信息,代表着普通账户或合约账户； 
	%Thus, for action transactions $\tx_a$ indicates the $160$-bit address of the recipient, which refers to either a normal account or a contract account;
	或当交易是一笔创建交易，则接收方为新创建的合同，且将 $\tx_a$ 认作 $\B_0$ 中的唯一元素，即 $\tx_a = \emptystring$。
	%otherwise in case of a creation transaction, the recipient is indeed the newly created contract and we interpret $\tx_a$ as the only element in $\B_0$ and write $\tx_a = \emptystring$.

	\item {\bf 交易额(value):} 一个标量值，等于在交易中发送方意图转给接收方（ $\tx_t$ 所表示的账户或一个新创建的合约）的金额的 Drip 数，记作  $\tx_v\in\N_{256}$。
	%\item {\bf value:} A scalar value equal to the amount of \unit that the transactions sender wants to transfer to the recipient, i.e. the account specified in $\tx_a$ or the newly created contract.Formally denoted by $\tx_v\in\N_{256}$.


	\item {\bf 存储上限(storageLimit):} 
	一个以字节为单位的标量值，表示 $\tx$ 执行所用的最大存储增量。
	正式记作 $\tx_{\ell}\in\N_{64}$.
	%A scalar value indicating the maximum increment of storage used in the execution of $\tx$, measured in bytes. Formally denoted by $\tx_{\ell}\in\N_{64}$.}

	\item {\bf 纪元高度(epochHeight):} 
	一个标量值，标明 $\tx$ 可被执行的纪元区间。正式记作 $\tx_e\in\N_{64}$，表示 $\tx$ 只可在 $[\tx_e - \txepochbound, \tx_e + \txepochbound]$ 区间内的纪元被执行。
	%A scalar value specifying the range of epochs where $\tx$ can be executed. Formally denoted by $\tx_e\in\N_{64}$ such that $\tx$ can only be executed between the epochs of $[\tx_e - \txepochbound, \tx_e + \txepochbound]$. }

	\item {\bf 链 ID(chainID):} 
	一个链 ID 值，表示 $\tx$ 想被执行的链 ID。正式记作 $\tx_c\in\N_{32}$，且 {\name} 的链特征是一个常数 $\tx_c=\chainid$。
	%A binary chain id indicating where $\tx$ is intended to be executed. Formally denoted by $\tx_c\in\N_{32}$ and the chain id of {\name} is a constant $\tx_c=503$.} 

	\item {\bf v, r, s:} 
	$\tx$ 的 ECDSA (椭圆曲线数字签名算法) 签名中相应的域，正式写为 $\tx_w$, $\tx_r$ 和 $\tx_s$。 
	%Corresponding fields of the recoverable ECDSA signature of $\tx$, formally denoted by $\tx_w$, $\tx_r$ and $\tx_s$. 
\end{itemize}

\smallskip
除以上两种类型交易的共有域之外，一笔交易可能包含以下布线长度的字节序列域之一，用以创建和调用合约：
%In additional to the shared fields, 
%a transaction may contain either of the following fields of unlimited length byte arrays for contract creation and invocation:
\begin{itemize}[nosep]
 	\item {\bf 初始化代码(init):} 
 	一个不限制大小的字节数组，用来指定账户初始化程序的 EVM 代码，正式记作 $\tx_{\bf i} \in \Byte^*$ 。
 	%A byte array specifying the \cvm code for the initialization procedure, formally denoted by $\tx_{\bf i} \in \Byte^*$.
 	\emph{初始化代码} 仅在合约创建时被执行一次，随后即被遗弃。
 	执行这段代码将返回另一代码片段 {\bf body}，这是合约账户每次收到消息调用时都会执行的实际合约代码（可以由交易或内部代码执行触发）。 
 	%Note that {\bf init} is executed once and discarded thereafter, and it returns another code fragment {\bf body} as the actual contract code that will be executed each time the contract account receives a message call (either through a transaction or due to the internal execution of code).


 	\item {\bf 调用数据(data):} 一个字节序列，表示对一个已存在的合约执行消息调用时的输入数据，正式写作 $\tx_{\bf d}\in \Byte^*$。
 	%\item {\bf data:} A byte array specifying the input data of the message call to an existing contract, formally denoted by $\tx_{\bf d}\in \Byte^*$.

 \end{itemize} 

函数 $\sender{\cdot}$ 通过可恢复 ECDSA 签名将每一笔交易与其发送方一一对应，即 $\sender{\tx}$ 代表交易 $\tx$ 的发送方。
%There is a function $\sender{\cdot}$ that maps a transaction to its sender using the recoverable ECDSA signature,
%i.e. $\sender{\tx}$ henceforth represents the sender of the transaction $\tx$.
%
方便起见，我们进一步定义函数 $L_{\tx}$ 对交易 $\tx$ 进行以下解析：
%For convenience, we further introduce the function $L_{\tx}$ that parses a transaction $\tx$ as follows:
\begin{align}\label{def:tx_prepare}
	L_{\tx}(\tx)\eqdef 
	\begin{cases}
	\left(\tx_n, \tx_p, \tx_g, \tx_a, \tx_v, \newversion{\tx_\ell,\tx_e,\tx_c,} \tx_{\bf i}, \tx_w,\tx_r,\tx_s \right) & \mbox{if $\tx_a=\emptystring$} \\
	\left(\tx_n, \tx_p, \tx_g, \tx_a, \tx_v, \newversion{\tx_\ell,\tx_e,\tx_c,} \tx_{\bf d}, \tx_w,\tx_r,\tx_s \right) & \mbox{otherwise}
	\end{cases}
\end{align}

\subsection{区块}
%\subsection{Blocks}
\label{sec:block}

{\name} 区块链的链上信息都被整理放置在各个区块之中。
%The {\name} blockchain organizes all on-chain information in blocks.
%
每个 {\name} 区块都由两个部分组成：一个区块头 $\head$ 和一个交易列表 $\txs$。
%Every {\name} block $\block$ consists of two parts: a block header $\head$ and a list of transactions $\txs$. 
区块头 $\head$ 包含一个名单，记录着其他未被引用的区块头（即 \emph{引用区块}）。
%The header $\head$ contains a list of other unreferenced block headers (a.k.a. \emph{referee} blocks or simply \emph{referees}).
区块头 $\head$ 是以下信息的集合：
%The block header $\head$ is a collection of relevant pieces of information:
\begin{itemize}[nosep]
	\item {\bf 父区块哈希(parentHash):} 父块的区块头的 256 比特 Keccak 哈希，记为
	$\head_p\in\B_{256}$。
	%\item {\bf parentHash:} The Keccak 256-bit hash of the parent block's header, formally denoted by $\head_p\in\B_{256}$.
	
	\item {\bf 高度(height):} 一个表示当前区块高度的标量值，也即从该区块到创世块所需经过的父引用关系数。正式表达为 $\head_h\in \N_{64}$。其中，创世块的高度为 $0$。
	%\item {\bf height:} A scalar value equal to the height of the block, which is also the number of parent references to reach the genesis block. This is formally denoted by $\head_h\in \N_{64}$. The genesis block has a height of zero. 
	
	\item {\bf 时间戳(timestamp):} 一个标量值，等于该区块创立时 Unix 时间戳。正式表达为 $\head_s \in \N_{64}$。
	%A scalar value equal to the reasonable output of Unix's time() at this block's inception. Formally denoted by $\head_s \in \N_{64}$.
	%\item {\bf timestamp:} A scalar value equal to the reasonable output of Unix's time() at this block's inception. Formally denoted by $\head_s \in \N_{64}$. 

	\item {\bf 挖掘者(author):} 该区块挖掘者的 $160$ 比特地址，正式记作 $\head_a \in \B_{160}$。这是受益人地址，用于接收所有因成功挖掘该区块而获得的奖励。
	%\item {\bf author:} The 160-bit address of the author of this block, formally denoted by $\head_a \in \B_{160}$. 
	%This is indeed the beneficiary's address to receive all rewards caused by successfully mining this block.

	\item {\bf 交易根哈希(transactionRoot):} 一个 trie 结构的 256 比特 Keccak 哈希根，该 trie 结构由区块交易列表中包含的每一笔交易而构造， 记为 $\head_t\in\B_{256}$。
	%\item {\bf transactionRoot:} The Keccak 256-bit hash of the root node of the trie structure populated with each transaction in the transaction list portion of the block, formally $\head_t\in\B_{256}$.

	\item {\bf 延迟状态根哈希(deferredStateRoot):} 在所有“稳定交易”被执行且确定后所得状态的 256 比特 Keccak 哈希委托，正式记作 $\head_r\in\B_{256}$。
	%\item {\bf deferredStateRoot:} The Keccak 256-bit hash commitment of the state after all ``stable transactions''  are executed and finalized, formally $\head_r\in\B_{256}$.
	需注意的是，因为 {\name} 的 \emph{延迟执行} 规则，“稳定交易”指包含该交易的区块先于 \deferblk 个纪元前的枢轴块，即沿父引用关系向上追溯 \deferblk 次。
	%Note that due to \emph{deferred execution} in {\name},  ``stable transactions'' are those included in the past blocks of the pivot block of \deferblk epochs ago, i.e. \deferblk steps along the parent references.
	\begin{itemize}
		\item 如果 {\bf blame} 的域值为零，即 $\head_m=0$，那么 $\head_r$ 是所有“稳定交易”被执行且确定后所得状态树的根。
		%\item If the {\bf blame} field is zero, i.e. $\head_m=0$, then $\head_r$ is the root node of the state trie after all ``stable transactions''  are executed and finalized.
	
		\item 否则，若 $\head_m>0$，$\head_r$ 将是一个向量的 256 比特 Keccak 哈希。该向量的组成部分是 满足前一情况的状态根，和所有 $\block$ 的祖先区块中 {\bf blame} 域值非零的校正后状态根。
		%\item Otherwise if $\head_m>0$, then $\head_r$ will be the Keccak 256-bit hash of the vector consisting of the state root in the previous case and the corrected state roots of $\block$'s ancestors until (not including) the first ancestor that is not blamed.
	\end{itemize}
	
	
	\item {\bf 延迟收据根哈希(deferredReceiptsRoot):} 当区块 \emph{延迟状态根哈希} 域更新时产生的每一笔交易收据的256 比特 Keccak 哈希承诺，正式记作 $\head_e\in\B_{256}$。
	%\item {\bf deferredReceiptsRoot:} The Keccak 256-bit hash commitment of the receipts of each transaction executed when updating the {\bf deferredStateRoot} field of the block, formally $\head_e\in\B_{256}$. 
	\begin{itemize}
		\item 若 {\bf blame} 域为非零，即 $\head_m=0$，$\head_e$ 是一个trie 结构的 256 比特 Keccak 哈希根，由当下纪元的所有交易收据共同构造。
		%\item If the {\bf blame} field is nonzero, i.e. $\head_m=0$, then $\head_e$ is the Keccak 256-bit hash of the root node of the trie structure populated with the receipts of transactions in the epoch that is just executed.
		
		\item 否则，若 $\head_m>0$，$\head_e$ 将是一个向量的 256 比特 Keccak 哈希。该向量的组成部分是 满足前一情况的收据根，和所有 $\block$ 的祖先区块中 {\bf blame} 域值非零的校正后收据根。
		%\item Otherwise if $\head_m>0$, then $\head_e$ will be the Keccak 256-bit hash of the vector consisting of the receipt root in the previous case and the corrected receipt roots of $\block$'s ancestors until (not including) the first ancestor that is not blamed.
	\end{itemize}
	
	
	\item {\bf 延迟日志过滤器哈希(deferredLogsBloomHash):} 一个关于 \emph{延迟状态根哈希} 域值更新所产生的所有交易收据的日志地址和日志标题等可索引信息的布隆过滤器（Bloom filter）的256 比特 Keccak 哈希承诺，记为 $\head_b$。	
	%\item {\bf deferredLogsBloomHash:} The Keccak 256-bit hash commitment of the Bloom filter composed from indexable information (logger address and log topics) contained in each log entry from the receipts of all transactions executed when updating the {\bf deferredStateRoot} field, formally $\head_b\in\B_{256}$.
	\begin{itemize}
		\item 若 {\bf blame} 域为非零，即 $\head_m=0$，$\head_b$ 是一个布隆过滤器的 256 比特 Keccak 哈希承诺，由当下纪元的所有交易收据共同构造。
		%\item If the {\bf blame} field is zero, i.e. $\head_m=0$, then $\head_b$ is the Keccak 256-bit hash commitment of the Bloom filter composed from receipts of transactions in the epoch that is just executed.
	
		\item 否则，若 $\head_m>0$，$\head_b$ 将是一个向量的 256 比特 Keccak 哈希。该向量的组成部分是 满足前一情况的布隆过滤器承诺，和所有 $\block$ 的祖先区块中 {\bf blame} 域值非零的校正后布隆过滤器承诺。
		%\item Otherwise if $\head_m>0$, then $\head_b$ will be the Keccak 256-bit hash of the vector consisting of the Bloom filter commitment in the previous case and the corrected Bloom filter commitments of $\block$'s ancestors until (not including) the first ancestor that is not blamed.
	\end{itemize}

	\item {\bf blame:} 一个标量值 $\head_{m}\in\N_{32}$，表示所在枢轴链中
	区块头执行状态域 \emph{延迟状态根哈希}, \emph{延迟收据根哈希}, \emph{延迟日志过滤器哈希}, 或 {\bf blame} 有误的区块个数。
	此域值（{\bf blame}）与奖励分配相关。
	例如，若 $\parent{\block}$ 在以上四个执行状态域都无误，则 $\head_{m}=0$；若 $\parent{\block}$ 在以上四个执行状态域的任意域有误，则 $\head_{m} \ge 1$。
	%\item {\bf blame:} A scalar value $\head_{m}\in\N_{32}$ indicating the number of immediate ancestors whose header is incorrect in the execution state fields: {\bf deferredStateRoot}, {\bf deferredReceiptsRoot}, {\bf deferredLogsBloomHash}, or {\bf blame}. 
	%This {\bf blame} field is relevant in reward distribution.\\
	%For example, if $\parent{\block}$ is correct on all the four fields then $\head_{m}=0$; if any of these fields is wrong in $\parent{\block}$, then $\head_{m} \ge 1$.

	\item {\bf 难度(difficulty):} 一个表示当前区块的目标难度等级的标量值 $\head_d\in\N_{256}$，通过之前区块的难度等级和时间戳计算得到。
	%\item {\bf difficulty:} A scalar value $\head_d\in\N_{256}$ specifying the target difficulty level of this block. This is calculated from the previous block's difficulty level and the timestamp.

	\item {\bf 自适应权重(adaptiveWeight):} 布林值 $\head_w\in\B$ 表示自适应权重是否被触发。
	%\item {\bf adaptiveWeight:} The Boolean value $\head_w\in\B$ indicating whether adaptive weight is triggered.

	\item {\bf 燃料量上限(gasLimit):} 一个表示当下每个区块燃料消耗上限的标量值。该值始于 $\head_{\ell}\in\N_{256}$。$\head_{\ell}(\gblock)\eqdef \startblockgastlimit=\startblockgastlimitline$。
	%\item {\bf gasLimit:} A scalar value $\head_{\ell}\in\N_{256}$ equal to the current limit of gas expenditure per block. 
	%Starting from $\head_{\ell}(\gblock)\eqdef \startblockgastlimit=\startblockgastlimitline$.

	\item {\bf 引用列表哈希(refereeHash):} 通过对引用列表进行序列化操作所得的 $\rlp$ 序列。该列表由引用区块的 256 比特 Keccak 哈希构成，正式表达为 $\head_o \in\Byte^*$。
	该列表最多由 $\numberofommers$ 个引用区块的哈希标识组成。
	方便起见，我们用 $\referees(\block)$ 表示区块 $\block$ 的这些引用区块。
	%\item {\bf refereeHash:} The serialized $\rlp$ sequence of the referee list consisting of  Keccak 256-bit hashes of referee blocks, formally denoted by $\head_o \in\Byte^*$. 
	%This list consists of up to $\numberofommers$ hash references of referee blocks.
	%For convenience, we let $\referees(\block)$ denote these referee blocks of a block $\block$.
	
	\item {\bf 自定义数据(customData):} 一个自定义域，包含一个任意长度的字节串列表 $\head_c\in (\Byte^*)^*$。
	%\item {\bf customData:} A customized field with an arbitrary length list of byte string $\head_c\in (\Byte^*)^*$. 

	% {The following corresponds to the PoW part:}
	\item {\bf mixHash:} 一个 256 比特哈希，用以与 \emph{序列号(nonce)} 共同证明当前区块已有足够计算量背书；正式表达为 $\head_x\in\B_{256}$。
	%\item {\bf mixHash:} A $256$-bit hash which, combined with the {\bf nonce}, proves that a sufficient amount of computation has been carried out on this block; formally $\head_x\in\B_{256}$. 

	\item {\bf 随机数(nonce):} 一个 256 比特的值，用于证明当前区块已有足够计算量背书，表示为 $\head_n\in\B_{256}$。
	%\item {\bf nonce:} A $256$-bit value which proves that a sufficient amount of computation has been carried out on this block, formally $\head_n\in\B_{256}$.


\end{itemize}

正式地，一个区块头的定义是
%Formally, a block header is defined as 
%
\begin{align}
	\head = (\head_p,\head_h,\head_s,\head_s,\head_a,\head_t,\head_r,\head_e,\head_b,\head_m,\head_d,\head_w,\head_\ell,\head_o,\head_c,\head_n)
\end{align}

需要注意的是，在 Oceanus 版本中 {\bf mixHash} 不属于区块头的一部分。
%Notice that the {\bf mixHash} is not a part of block header in Oceanus. 

$\block$ 的另一部分是一个交易列表。因此区块 $\block$ 可使用以下表示：  
%The other part of $\block$ is simply a list of transactions. Therefore the block $\block$ can be represented as follows:
\begin{align}
	\block\equiv \left(\block_\head, \block_\txs \right)
\end{align}

% \note{We notice that in many situations it is more convenient to have a list of all blocks in an epoch (under the pivot block's view) rather than a list of {\bf directly referenced blocks}. It is under discussion whether $\head_o$ should be a list of all other blocks in the epoch, i.e. $\epoch(\block)-\block \eqdef  \past(\block) - \past(\parent{\block})- \parent{\block}$ including those blocks indirectly referenced by direct referred blocks of $\block$, so that it is clear from $\block$ itself what its epoch looks like.

\subsubsection{交易收据}
%\subsubsection{Transaction Receipt}

为了方便快速地验证交易结果，我们在每笔交易执行过程中记录下一些特定的信息并编码为 \emph{“交易收据”}。
%For convenience and easy verification of the outcome of transaction execution, we introduce \emph{transaction receipt} to record certain information of every executed transaction.
每当更新一个区块的 \emph{延迟状态根哈希} $\head_r$ 时，
我们以 $\block_{\rec}[i]$ 表示第 i 笔交易的收据，将所有收据储存在一个以索引为键的 trie 树里。
此树根的哈希值 $\head_e\in\B_{256}$ 被存储在区块头中。
%When updating the {\bf deferredStateRoot} $\head_r$ of a block,
%we encode a receipt $\block_{\rec}[i]$ for the $i$-th executed transaction and store these receipts in an index-keyed trie.
%This root is recorded in the header as $\head_e\in\B_{256}$.

每一笔已执行的交易 $\tx$ 的收据都是一个九元组 $R\eqdef \left(R_u, R_f, R_g, R_b, R_{\bf l}, R_z,R_{\bf o},R_s,R_{\bf i}\right)$ ：
%For every executed transaction $\tx$, the receipt $R\eqdef \left(R_u, R_f, R_g, R_b, R_{\bf l}, R_z,R_{\bf o},R_s,R_{\bf i}\right)$ is a tuple consisting of six fields:
\begin{itemize}[nosep]
	\item $R_u\in\N_{256}$ 为 \emph{包含交易 $\tx$ 收据的纪元} 中当该笔交易 $\tx$ 发生后的累积 gas 使用量;
	%\item $R_u\in\N_{256}$ is the cumulative gas used \emph{in the epoch where $\tx$ is executed} as of immediately after $\tx$ has been processed;
	
	\item $R_f\in\N_{256}$ 是当下交易收取的 gas 费用。
	%\item $R_f\in\N_{256}$ is the gas fee charged for the current transaction. 
	
	\item $R_g \in \B$ 表示 gas 费用是否被赞助。
	%\item $R_g \in \B$ denotes whether the gas fee is sponsored. 

	\item $R_{\bf l}$ 是交易 $\tx$ 执行中产生的日志集合。
	%\item $R_{\bf l}$ is the set of logs created in the execution of $\tx$;

	\item $R_b\in\B_{2048}$ 是由 $R_{\bf l}$ 中的日志所组成的布隆过滤器。
	%\item $R_b\in\B_{2048}$ is the Bloom filter composed from logs in $R_{\bf l}$;

	\item $R_z\in\N$ 是交易 $\tx$ 的状态代码。
	%\item $R_z\in\N$ is the status code of the transaction $\tx$.
	
	\item $R_s \in \B$ 表示存储抵押是否被赞助。
	%\item $R_s \in \B$ denotes whether the storage collateral is sponsored. 
	
	\item $R_{\bf o}$ 是 $\tx$ 的执行中地址的存储增量（以字节为单位）的集合。
	%\item $R_{\bf o}$ is the set of incremental storage (in bytes) for addresses in the execution of $\tx$;

	\item $R_{\bf i}$ 是 $\tx$ 的执行中地址的存储减量（以字节为单位）的集合。
	%\item $R_{\bf i}$ is the set of decremental storage (in bytes) for addresses in the execution of $\tx$;
\end{itemize}

序列 $R_{\bf l}\eqdef \left(O_0,O_1,\dots\right) \in \left(\B_{160} \times \left(\B_{256}\right)^*\times \B_*\right)^*$ 由一系列日志条目组成，
%The sequence $R_{\bf l}\eqdef \left(O_0,O_1,\dots\right) \in \left(\B_{160} \times \left(\B_{256}\right)^*\times \B_*\right)^*$ is a series of log entries,
其中每条日志 $O$ 都是一个三元组。该三元组包括日志地址 $O_a\in \B_{160}$ ，
%where each log entry $O$ is a tuple of the logger's address $O_a\in \B_{160}$,
可为空集的 256 比特日志标题 $O_{\bf t}\eqdef \left(O_{{\bf t}_0}, O_{{\bf t}_1},\dots \right)$（其中 $O_{{\bf t}_i}\in\B_{256}$ 所有的自然数 i 都成立），
%a possibly empty series of $256$-bit log topics $O_{\bf t}\eqdef \left(O_{{\bf t}_0}, O_{{\bf t}_1},\dots \right)$, such that $O_{{\bf t}_i}\in\B_{256}$ for every $i\in\N$,
以及数据序列 $O_{\bf d}\in\B_*$：
%and a sequence of data $O_{\bf d}\in\B_*$:
\begin{align}
	O\eqdef \left( O_a, O_{\bf t}, O_{\bf d} \right)
\end{align}

布隆过滤器函数 $M$ 将一条日志缩减为一个 256 字节（2048 比特）哈希值：
%The Bloom filter function $M$ reduces a log entry into a single $256$-byte ($2048$-bit) hash as follows:
\begin{align}
 	M(O)\eqdef \bigvee_{x\in\set{O_a}\union O_{\bf t}}\left( M_{3:2048}(x) \right)
\end{align} 
其中 $M_{3:2048}$ 是一个特定的布隆过滤器，
%where $M_{3:2048}$ is the specialized Bloom filter
它根据一个随机字节序列的输入，将 2048 位中的 3 位数值设置为 1。
%that sets three out of $2048$ bits to $1$ on input of an arbitrary byte sequence,
正式定义请见 \cite{ETH_yellow}。
%as formally defined in \cite{ETH_yellow}.

序列 $R_{\bf o}\eqdef \left(P_0,P_1,\dots\right) \in \left(\B_{160} \times \B_{256}\right)^*$ 中每一项 $P$ 都是一个由地址，该地址的存储抵押增量组成的元组。
%The sequence $R_{\bf o}\eqdef \left(P_0,P_1,\dots\right) \in \left(\B_{160} \times \B_{256}\right)^*$ where each entry $P$ is a tuple of an address and the incremental storage collateral of such address. 
$R_{\bf o}$ 仅收集存储抵押增量为正的地址。
%$R_{\bf o}$ only collects the addresses with positive incremental storage collateral. 
其以地址进行升序排列，且每个地址只出现一次。
%It is sorted in ascending order of addresses and each address only appears once. 
$R_{\bf i}$ 和 $R_{\bf o}$ 的设置相同。
%$R_{\bf i}$ has the same settings as $R_{\bf o}$.

\subsubsection{序列化}
%\subsubsection{Serialization}

函数 $L_B$ 和 $L_H$ 分别是区块和区块头的预备函数（定义类似于 \cref{def:tx_prepare} 中定义的 $L_{\tx}$），其中 $L_{\tx}^*$ 和 $L_H^*$ 如前文中定义，代表逐元素序列转化。
%The function $L_B$ and $L_H$ are the preparation functions for a block and block header respectively (similar as $L_{\tx}$ defined in \cref{def:tx_prepare}),
%where we recall that $L_{\tx}^*$ and $L_H^*$ refer to element-wise sequence transformations.
当需要使用 $\rlp$ 转换时，我们要求结构的类型和顺序如下：
%We assert the types and order of the structure when the $\rlp$ transformation is required:
%
\begin{align}
	L_H(\head) &\equiv \left(\head_p,\head_h,\head_s,\head_s,\head_a,\head_t,\head_r,\head_e,\head_b,\head_m,\head_d,\head_w,\head_\ell,\head_o,\head_c[0],\cdots,\head_c[-1],\head_n\right)\\
	L_B(\block) &\equiv \left( L_H(\block_\head), L_{\tx}^*(\block_\txs) \right)
\end{align}

另外，我们用 $L_O$ 表示引用区块的预备方程，其定义如下：
%In addition, we let $L_O$ be the preparation function for the referee blocks as follows:
\begin{align*}
	L_O(\head)\equiv L_H^*(\head_o)
\end{align*}

其中各个组成部分的类型定义如下：
%The component types are defined thus: 
\begin{align}
	& \head_p \in \B_{256} 
	\qquad &\land \qquad &\head_h\in \N_{64}
	\qquad &\land \qquad &\head_s\in \N_{64}
	\qquad &\land \qquad &\head_a\in \B_{160}
	\qquad &\land \qquad &\head_t\in \B_{256}
	\notag\\
	\land \qquad &\head_r\in \B_{256}
	\qquad & \land \qquad &\head_e\in \B_{256}
	\qquad &\land \qquad &\head_b\in \B_{256} 
	\qquad &\land \qquad &\head_m\in \N_{32}	
	\qquad &\land \qquad &\head_d\in \N_{256}	
	\notag\\
	\land \qquad &\head_w\in \B
	\qquad &\land \qquad &\head_\ell\in \N_{256}	% \qquad \land \qquad \head_g\in \B_{256}
	\qquad &\land \qquad &\head_{o} \in\left(\B_{256}\right)^{\le \numberofommers}
	% TODO: The Oceanus doesn't include mix-hash in block header
	% \qquad &\land \qquad &\head_x\in \B_{256}
	\qquad &\land \qquad &\head_n\in \B_{256}
\end{align}

这样我们就已经严格定义了一个区块结构需要的所有元素。
通过 $\rlp$ 转换，我们可以将该结构进一步序列化为一个方便网络传输和本地储存的字节序列。
%Now we have the specification for the construction of a formal block structure. 
%With the $\rlp$ transformation we can further serialize this structure into a sequence of bytes ready for transmission and storage. 

  
\subsubsection{良构性}
%\subsubsection{Well-formedness}
\label{sec:internal consistency}
当且仅当一个（区块头为 $\head=\head(\block)$ 的） {\name} 区块 $\block$ 是自洽且符合以下条件的，我们成改区块为良构的：
%Every {\name} block $\block$ (with header $\head=\head(\block)$) is \emph{well-formed} if and only if it is internally consistent and satisfies the following: 
\begin{align}
	\head_t = \trie\left(\forall i<||\block_{\txs}||, i\in \N: \left(\rlp(i),\rlp(L_{\tx}(\block_{\txs}[i]))\right) \right)  
\end{align}

直观而言，若一个区块 $\block$ 的区块头 $\head$ 与其区块内容是一致的，则它是良构的。
%Intuitively, a block $\block$ is well-formed if its header $\head$ is consistent with the contents inside $\block$.
换言之，区块头 $\head$ 有效代表了整个区块 $\block$。
%In other words, $\head$ effectively represents the whole block $\block$.




\subsubsection{区块头的合法性}
%\subsubsection{Block Header Validity}
\label{sec:valid header}

为了判断一个区块 $\block$ 的区块头 $\head=\head(\block)$ 是否合法，
%Given a block $\block$ with header $\head=\head(\block)$, 
我们将检查区块头 $\head$ 的以下域，并在必要时将其与 $\head\big(\parentf(\block)\big)$ 和 $\past(\block)$ 进行对比：
%we decide whether the header $\head$ is valid by checking the following fields of $\head$
%and comparing to $\head\big(\parentf(\block)\big)$ and $\past(\block)$ when necessary:

\begin{itemize}[nosep]
	\item 高度增加一；
	\item 以 Unix 时间计算的时间戳有所增加；
	%\item the height is increased by one;
	%\item the timestamp (in Unix's time()) is increased;

	\item 燃料消耗上限的变化不超过 $1/1024$，且不低于 $\minblockgaslimit$；
	%\item the canonical gas limit does not change too much (i.e. more than $1/1024$) and it remains above $\minblockgaslimit$;

	\item 目标难度按照第 \ref{sec:difficulty} 节正确设置；
	%\item the target difficulty is properly set according to Section~\ref{sec:difficulty};

	\item 工作量证明符合目标难度值；
	%\item the proof-of-work quality exceeds the target difficulty; 

	% \item the {\bf extraData} is no more than $32$ bytes;

	\item 在区块 $\block$ 的 \emph{过去区块} 中，其父块的选择遵守 GHAST 规则\cite{GHOST}；
	%\item the parent is chosen properly from $\past(\block)$ (the past view of $\block$) following the GHAST rule;

	\item 对于 $\block$ 的过去区块，自适应权重标志 {\bf adaptiveWeight} 必须根据 GHAST 规则正确设置
	%\item the adaptive weight flag {\bf adaptiveWeight} must set properly according to the GHAST rule with respect to $\past(\block)$;

	% \item the deferred receipt root {\bf deferredReceiptRoot} and deferred Bloom filter of receipt logs {\bf deferredLogsBloomHash} must be correct as right after $\epf\left(\parentf^{(\dfb)}(\block)\right)$;

	% \item the blame value {\bf blame} must be correct;

	% \item the transaction root {\bf transactionRoot} is properly generated;

	\item 引用列表 {\bf refereeHash} 适当地分化为区块头。
	%\item the referee list {\bf refereeHash} properly decomposes to block headers.

\end{itemize}

\medskip

正式地，当且仅当区块头 $\head$ 满足以下条件时， 它是合法的：
%Formally, the header $\head$ is valid if and only if: 


\begin{align}
	&{\head_h} = \head\left(\parentf(\block)\right)_{h}+1\\
	\land \qquad &{\head_s} > \head\left(\parentf(\block)\right)_{s}\\
	\land \qquad & \left|{\head_l} -\head\left(\parentf(\block)\right)_{l}\right|< \left\lfloor\frac{\head\left(\parentf(\block)\right)_{l}}{1024}\right\rfloor \qquad
	\land \qquad {\head_l}\ge \minblockgaslimit \label{eq:blockgas}\\
	\land \qquad & \text{${\head_d}$ is legitimate according to the difficulty adjusting function}\\
	% TODO: the Oceanus doesn't have mix-hash in block header. But we haven't decided whether to include it in the final version.
	% \land \qquad & \text{${\head_x}$ is the correct mix-hash (see (\ref{eq:mixhash}) in Section~\ref{sec:pow})}\\
	\land \qquad & \quality(\head) \ge {\head_d}\\
	\land \qquad & \newversion{\text{$\parentf(\block)$ specified by ${\head_p}$ is legitimate according to GHAST rule in $\past(\block)$}}\\
	\land \qquad & \newversion{\text{${\head_w}$ is legitimate according to the GHAST rule in $\past(\block)$}}\\
	% \land \qquad & 
	% \oldversion{{\head_r} = \trie\left( L_S\left(\transition\left(\st, \epf\left(\parentf^{(\deferblk)}(\block)\right)\right)\right) \right) \label{eq:stateroot}}\\
	% \land \qquad & 
	% \newversion{\text{${\head_e}$ and ${\head_b}$ properly encode receipts generated in the execution of $\epf\left(\parentf^{(\deferblk)}(\block)\right)$}}\\
	% \land \qquad & \newversion{\text{${\head_m}$ is legitimate according to the Blaming rule}}\\
	\land \qquad & \newversion{\text{${\head_o}$ is well-formed and encodes referee block headers}}
\end{align}



\newversion{
	区块头 $\head$ 的合法性仅与区块全序的共识有关，并不依赖于区块头内与执行相关的域({\bf deferredStateRoot}, {\bf deferredReceiptsRoot}, {\bf deferredLogsBloomHash} 和 {\bf blame})的正确性，即 $\head$ 中 ${\head_r}, {\head_e}, {\head_b}$ 和 ${\head_m}$ 的正确性。
	%We remark that the validity of $\head$ only matters for consensus of total order of blocks,and it \emph{does not} rely on the correctness of the execution related fields {\bf deferredStateRoot}, {\bf deferredReceiptsRoot}, {\bf deferredLogsBloomHash} and {\bf blame} of the header, i.e. ${\head_r}, {\head_e}, {\head_b}$ and ${\head_m}$ of $\head$ respectively.
	然而，这些域的错误值可能表明区块挖掘者未能维持(Conflux 系统的)状态并正确地执行交易。
	%However, being incorrect in these fields may indicate that the author of the block fails to maintain the state and execute the transactions properly, 
	这种情况下，我们仍承认该区块对共识所作的贡献，但挖掘者不得到任何奖励。
	%in which case we still count the contribution of this block to consensus but the author gets no reward,
	以上内容在第 \ref{sec:blaming} 和 \ref{sec:incentive} 节中进行了讨论。
	%as discussed in Section~\ref{sec:blaming} and Section~\ref{sec:incentive}.
}

\subsubsection{部分（不）合法区块}
%\subsubsection{Partially (In)Valid Blocks}
\label{sec:pvalid header}


若一个区块 $\block$ 的父区块 $\parent{\block}$ 被标记为部分合法，或该区块自身的区块头 $\head=\head(\block)$ 满足第 \ref{sec:valid header} 中以下除外的所有条件，我们称其为 \emph{部分合法} 的：
%We call a block $\block$ \emph{partially valid} if 
%\newversion{either $\parent{\block}$ is marked as partially valid or} 
%its header $\head=\head(\block)$ passes all the assertions as in Section~\ref{sec:valid header} except for the following:
\begin{itemize}
	%\oldversion{\item the deferred state root $\head_r$ is incorrect;}

	%\oldversion{\item the parent reference $\parent{\block}$ specified by $\block_{\head_p}$ is not chosen by the GHOST rule in $\past(\block)$.}

	\newversion{
	\item $\head(\block)_{p}$ 所标明的父块 $\parent{\block}$ 没有遵循 GHAST 规则选择（对 $\past(\block)$ 而言）
	%\item the parent reference $\parent{\block}$ specified by $\head(\block)_{p}$ is not chosen properly according to the GHAST rule in $\past(\block)$;

	\item 自适应权重标志 $\head(\block)_{w}$ 没有根据 GHAST 规则正确设置（对 $\past(\block)$ 而言）
	%\item the adaptive weight flag $\head(\block)_{w}$ is not set properly according to the GHAST rule in $\past(\block)$;

	\item 目标难度 $\head(\block)_{d}$ 满足了难度调整的阈值条件，但没有按照 GHAST 难度调整函数被正确计算。
	%\item the target difficulty $\head(\block)_{d}$ satisfies the threshold condition of difficulty adjustment but it is not calculated properly according to the GHAST difficulty adjusting function.}
\end{itemize}


一个部分合法区块在其发布后的几小时内不能被诚实区块引用。
%A partially valid block may not be referenced by honest blocks in several hours after it is released.
当一个区块变老并不再能影响枢轴链时，我们不关心该区块是否为部分合法。详情请见第 \ref{sec:block validate} 节。 
%When a block becomes old and loses the ability to influence the pivot chain, we do not care about whether a block is partially valid or not. See Section~\ref{sec:block validate} for details. 
在一个部分合法区块被确认后，除了 timer 链的决定（见第 \ref{sec:timer chain}），它将被当成一个完全合法区块对待。
%Once a partially valid block is accepted, then it is treated as a fully valid block except for the decision of timer chain (Section~\ref{sec:timer chain}).


只要目标难度和工作量证明是合理的，部分合法区块仍可以对系统的吞吐率产生贡献。
%We note that as long as the target difficulty is legitimate and the proof of work is valid, the partially valid block can still contribute to the throughput.
这是因为我们允许引用部分合法区块，其所含的交易因此将和在完全合法区块中一样被正常处理和执行。
%This is because we allow referencing partially valid blocks and the transactions inside will be processed as in any fully valid block.
% 
需要特别注意的是，因为部分合法区块的挖掘者将得不到任何奖励，若交易仅被打包在部分合法区块，其交易费有可能被烧掉。
%We further remark that since the producer of a partially valid block is entitled to no reward, transaction fees may be burnt in case these transactions are only collected in partially valid blocks.







\subsubsection{Blaming Mechanism}
\label{sec:blaming}
	
	The {\bf blame} field is introduced for easy verification of states by light nodes.
	Intuitively, this field represents the vote to the latest ancestor block which commits to a correct state, 
	i.e. the author of the current block agrees with the committed state (represented in {\bf deferredStateRoot}, {\bf deferredReceiptsRoot}, {\bf deferredLogsBloomHash}, and {\bf blame}) of that block.
	We emphasize that these fields are \emph{not} checked for validity of a block, however, committing to an incorrect state may lead to loss of block reward.



	More specifically, $\head(\block)_{m}$ should be set to the minimum non-negative number such that $\parentf^{\left(\head(\block)_{m}+1\right)}(\block)$ is correct on all the four fields of {\bf deferredStateRoot}, {\bf deferredReceiptsRoot}, {\bf deferredLogsBloomHash}, and {\bf blame}.
	For example, $\head(\block)_{m}$ should be $1$ if $\parent{\block}$ is incorrect in $\head(\parent{\block})_{r}, \head(\parent{\block})_{e}, \head(\parent{\block})_{b}$ or $\head(\parent{\block})_{m}$ while $\parentf^{(2)}(\block)$ is correct in these fields.

	Then, in the current block $\block$'s view, all blocks in between of $\block$ and $\parentf^{\left(\head(\block)_{m}+1\right)}(\block)$, i.e. $\parentf(\block), \cdots, \parentf^{\left(\head(\block)_{m}\right)}(\block)$, are committing to incorrect states, for which we say that those blocks are (directly) \emph{blamed} by $\block$.
	Furthermore, since $\block$ agrees with the state committed in $\parentf^{\left(\head(\block)_{m}+1\right)}(\block)$,
	the blocks blamed by $\parentf^{\left(\head(\block)_{m}+1\right)}(\block)$ is also (indirectly) blamed by $\block$, and recursively we can determine all the blocks on $\chain(\block)$ that are blamed by the newest block $\block$.

	For blocks off $\chain(\block)$ (which is indeed the pivot chain in $\past(\block)$ as long as $\block$ is valid), 
	we do a best effort test to decide whether they are blamed by $\block$.
	More precisely,
	every block $\block'$ must have determined a set of blocks blamed by $\block'$ along $\chain(\block')$,
	and $\block'$ is blamed by $\block$ if they do not agree on exactly the same set of blamed blocks in the intersection $\chain(\block)\bigcap\chain(\block')$.
	We remark that no further check is applied on the execution related fields $\block'_r,\block'_e,\block'_b$ of $\block'$ as long as $\block'$ is off the current pivot chain.

	Thus we have determined for every block $\block'$ whether it is blamed by any other block $\block$.
	The punishment for blamed blocks (in particular, those blamed by the latest block on the pivot chain) is specified in Section~\ref{sec:incentive}.

	In addition, the fields of state commitments, i.e. {\bf deferredStateRoot}, {\bf deferredReceiptsRoot}, {\bf deferredLogsBloomHash}, 
	would be handled differently when being blamed, as briefly described at the beginning of Section~\ref{sec:block}.
	That is, if $\head_m>0$ and the those fields are blamed, 
	then the commitment will be a Keccak hash of the vector consisting of the correct commitments.
	For example, if a block $\block$ has $\head(\block)_m=2$ such that $\parentf(\block),\parentf^{(2)}(\block)$ are blamed but $\parentf^{(3)}(\block)$ is not, then the {\bf deferredStateRoot} field 
	$\head(\block)_r$ of block $\block$
	would be 
	\begin{align}
		\head(\block)_r = \kec\left( \mathrm{CorrectDeferredStateRoot}(\block), \mathrm{CorrectDeferredStateRoot}\big(\parentf(\block)\big), \mathrm{CorrectDeferredStateRoot}(\parentf^{(2)}\big(\block)\big) \right)
	\end{align}
	where $\mathrm{CorrectDeferredStateRoot}(\cdot)$ is the function that returns the correct value of the deferred state root, 
	which is a $256$-bit Keccak hash, that should be filled in the given block.
	Note that 1) $\rlp$ serialization is not used in the vector since each element has fixed length,
	and 2) the vector length only depends on the {\bf blame} field, regardless of correctness of individual fields in  blamed blocks.
	Similar rules apply to  {\bf deferredReceiptsRoot} and {\bf deferredLogsBloomHash}, i.e. $\head(\block)_e$ and $\head(\block)_b$.

