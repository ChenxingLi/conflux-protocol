% !TEX root = ./tech-specification.tex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{约定和术语}

本文中将使用以下常规表示法:  
\begin{itemize}[nosep]
	\item $\B$ 表示比特取值的集合，即 $\B\eqdef \zo$。
	$\Byte$ 表示一个字节取值的集合，即 $\Byte\eqdef \set{0,\dots,255}$。
	
	
	\item $\N$ 为所有非负整数的集合。
	
	
	\item 对于 $n\in \N$，我们用 $\B_n$ 表示一个 $n$ 位的二进制字符串，用 $\Byte_n$ 表示一个 $n$ 字节的二进制字符串。
	因此，$\Byte=\B_8$。
	\begin{itemize}[nosep]
		\item 另外，我们分别用 $\B^*$  和 $\Byte^*$ 表示一个任意长度的二进制串或字符串，即 $\B^*\eqdef \cup_{i\in\N} \B_i$，$\Byte^*\eqdef \cup_{i\in\N} \Byte_i$。
		
		\item 方便起见，我们用 $\N_{n}\eqdef\set{0,1,\dots, 2^n-1}$  表示小于 $2^n$ 的非负整数集合。
		
		\item $\emptystring$ 表示空字符串（或空序列），区别于空集的表示 $\varnothing$.
	\end{itemize}
	
	
	\item 默认情况下，数字采用十进制。我们将用方括号和下标注明二进制数字，例如 $[0100]_2$ 是 $4$ 的 $4$ 位二进制表达。
	下标 \textsf{ch} 是位串的字符表达，例如 $[{\sf ab}]_{\sf ch}=[6162]_{16}=[0110000101100010]_2$。
	%The subscript \textsf{ch} represents the character representation of bit string, e.g. $[{\sf ab}]_{\sf ch}=[6162]_{16}=[0110000101100010]_2$.
	
	
	\item 将 $\N_{256}$ 表示为256位二进制整数时，该表达以大端字节序存储。
	%When interpreting 256-bit binary values from $\N_{256}$ as integers, the representation is big-endian.	
	
	
	\item 当256位的二进制机器数据字符串与160位二进制的地址或哈希值字符串相互转化时，我们将使用最右侧的（即大端字节序下的低位）160位（20字节），丢弃最左侧的96位（12字节）或用零将其填充。	
	%When a 256-bit machine datum in $\B_{256}$ is converted to and from a 160-bit address or hash in $\B_{160}$, the rightwards (low-order for BE) 160 bits (20 bytes) are used and the leftmost 96 bits (12 bytes) are discarded or filled with zeros, thus the integer values (when the bytes are interpreted as big-endian) are equivalent.
	
	
	
	\item 我们使用形如  $\mathbf{A}$ 的黑体大写字母表示多元组。
	本文中较为常用的多元组包括：$\tx$ 表示一笔{\name}的交易；$\block$表示一个{\name}的区块；$\head$ 表示一个区块头等。
	\begin{itemize}[nosep]
		\item 我们用脚标来指定一个多元组的特定组成部分。例如：$\tx_n$ 表示交易 $\tx$ 的序列号（（nonce）。
		脚标与通过脚标所指定的元素在类型上保持一致，例如区块头本身也是一个多元组，所以用 $\block_{\head}$ 表示区块 $\block$ 的区块头。
		为使符号尽可能简洁，我们定义 $\head(\block)\eqdef \block_{\head}$，在不产生歧义的情况下也直接写作 $\head$。
		同样为了简洁性，我们在无歧义时会互换使用 $\block$ 和 $\head$ 表达相同含义。
		%（interchangably）：原翻译： 同样为了简洁性，我们会在没有歧义的情况下交替使用 $\block$ 和 $\head$。
		例如，$\block_d$ 表示区块 $\block$ 的目标难度，其更为正式的表达是 $\head(\block)_d$ 或 $\block_{\head_d}$ 。
		
		
		\item 当考虑很多的交易或者区块时，我们加入上标来表示其中的特定一个，例如 $\tx^1$ 表示一个序列中的第一笔交易。
	\end{itemize}
	
	
	\item 我们通常用 $\graph$ 表示区块的树图结构，即一个由顶点表示区块、由两种定向边表示父边连接关系和引用连接关系的图。
	%\newversion{The \tg structure of blocks is typically denoted by $\graph$, which is a graph consisting of blocks represented by vertices and parent/referee relations represented by two kinds of directed edges.}	   
	
	
	\item 标量和长度一定的元素序列（数组、字符串和矢量）将被表示为小写字母，例如 $n$ 表示一个交易的现时。
	其中具有特殊意义者将写为希腊字母。
	
	
	\item 不定长度的序列一般用黑体小写字母表示，例如 $\mathbf{o}$ 代表一次消息调用产生的输出字符串。
	
	
	\item 具有高度结构性的状态值一般写为黑体小写希腊字母，例如 $\st$ （及其变体）用于代表世界状态，$\mst$ 代表机器状态。
	% \begin{itemize}[nosep]
	
	% \end{itemize}
	
	\item 方括号将用于指明一个序列中的子序列，起始于 $0$ 。
	例如 $\mst_{\mathbf{s}}[0]$ 表示机器的栈中的第一个元素，$\mst_{\mathbf{m}}[0\dots 31]$ 表示机器内存中的前 $32$ 个元素。
	
	\begin{itemize}[nosep]
		\item 全局状态 $\st$ 可被理解为多个键值组合的集合。
		因此，$\st$ 后的方括号代表所述键相应的值（例如，账户地址）。
		%Some objects like the global state $\st$ is interpreted as a set of key/value pairs. Thus the square bracket after $\st$ refers to corresponding value of the given key (i.e., account address). 
		%原翻译：全局状态 $\st$ 可以被理解为所有账户状态的序列，其中每一个账户都是一个多元组。因此 $\st$ 后面出现方括号将表示一个或多个账户。
		
		\item 与Python语法相同，在方括号内使用负序号代表从末端访问一个数组。例如，$\mst_{\mathbf{s}}[-1]$ 代表机器的栈中的最后一个元素。
		%Square brackets use negative index to access an array from the end like Python, e.g. $\mst_{\mathbf{s}}[-1]$ refers the last item on the machine's stack. 
	\end{itemize}
	
	
	\item 函数一般将写为大写字母，其下标将表示特定的变体，例如 $C$ 表示一般的费用函数，而 $C_{\mathsf{SSTORE}}$ 表示 $\op{CALL}$ 操作的特定费用函数。
	关于状态操作的具体函数将被书法体大写字母表示，例如 $\transition$ 表示{\name}的全局状态转换函数。
	
	\begin{itemize}[nosep]
		\item 对于定义在 $D$ 上的函数 $F$，$F^*$ 表示一个定义在 $D^*$ 上的函数，效果是将函数 $F$ 应用于其输入的每一个元素之中，换言之 $F^*\big( \left(x_1, x_2, \dots\right) \big) \eqdef \left( F(x_1), F(x_2),\dots \right)$。
	\end{itemize}
	
	
	\item 函数上标的括弧表示递归调用函数的次数，例如 $f^{(i)}$ 表示递归调用 $f$ 函数共 $i$ 次。正式定义下, $f^{(1)}(\cdot)\eqdef f(\cdot)$ ，且对于 $i\ge 2$ 有 $f^{(i)}(\cdot)\eqdef f^{(i-1)}(f(\cdot))$。
	
	
	\item 指示函数 $\mathbb{I}(\cdot)$ 将一个布尔变量转化为整数。正式定义下，$\mathbb{I}(\true)=1$ 且 $\mathbb{I}(\false)=0$。
	%The indicator function $\mathbb{I}(\cdot)$ converts a boolean variable to integer. Formally, $\mathbb{I}(\true)=1$ and $\mathbb{I}(\false)=0$.
	
\end{itemize}  

\smallskip

常用函数:

\begin{itemize}[nosep]
	\item $\parentf$: \emph{父块函数} $\parentf$ 的输入为一个区块 $\block$，输出为 $\block$ 的父块 $\block'$，即输出被区块 $\block$ 作为父块引用的区块 $\block'$。
	正式表达为 $\parentf(\block)\eqdef \block':\kec\left(\rlp(\block')\right)=\head(\block)_{p}$.
	\footnote{因为 $\kec$ 函数在理论上存在碰撞的可能性，有人可能对 $\parentf$ 定义的无歧义性持怀疑态度。然而，在实际操作中未曾发生碰撞，因此函数 $\parentf$ 只需在已观测到的区块中寻找到 $\block'$，若没有找到则返回 $\bot$。
		%One may argue whether $\parentf$ is well-defined since $\kec$ has collisions. However, as long as the collision cannot be found in practical situations, the function $\parentf$ only need to look up such a $\block'$ from existing blocks and returns $\bot$ if there is none.
	}
	
	\item $\chain$:  \emph{链函数} $\chain$ 的输入为一个区块 $\block$，输出为从区块 $\block$ 开始递归地经父边引用直到最终到达创始块的整条链。正式而言，对于创始块 $\gblock$，$\chain(\gblock)\eqdef\gblock$；而对于其他区块 $\block$，$\chain(\block)\eqdef\chain(\parentf(\block))\circ \block$。
	
	
	\item $\sible$:  \emph{姐妹函数} $\sible$ 的输入为一个区块 $\block$，输出为与区块 $\block$ 有相同父块的所有其他区块。
	在形式上我们定义 $\sible(\block)\eqdef\{\block'|\parentf(\block')=\parentf(\block) \wedge \block'\neq \block\}$。
	
	
	\item $\past$: \emph{过去函数} $\past$ 以一个区块 $\block$ 为输入，并输出所有被 $\block$ 承认在其之前产生的区块，即所有直接或间接地被 $\block$ 引用的区块。$\block$ 不能引用自身，因此 $\past(\block)$ 集合不包含 $\block$。
	
	
	\item $\future$: \emph{未来函数} $\future$ 以一个树图  $\graph$ 和一个区块 $\block$ 为输入，输出所有在 ``$\block$ 的未来集合''中的区块，
	正式定义下，$\future(\block;\graph)\eqdef\{\block' \in \graph \mid \block \in \past(\block')\}$。
	%the \emph{future function} takes a \tg $\graph$ and a block $\block\in\graph$ as inputs and outputs all blocks in the  ``future set of $\block$''. Formally, $\future(\block;\graph)\eqdef\{\block' \in \graph \mid \block \in \past(\block')\}$. 
	
	
	\item $\epf$:  \emph{纪元函数} $\epf$ 以一个区块 $\block$ 作为输入，以\name 所定义的全序（详见第 \ref{sec:total order} 节）输出 $\block$ 所在纪元的所有区块。 
	%the \emph{epoch function} takes a block $\block$ as input and returns a sequence of all blocks in the epoch of $\block$, sorted as in the \name total order defined in Section~\ref{sec:total order}.
	%原翻译：\emph{纪元函数} $\epf$ 以一个区块 $\block$ 作为输入，输出所有跟 $\block$ 处在同一个纪元的区块，且输出顺序遵循 \name 所定义的全序（定义详见第 \ref{sec:total order} 节）。
	
	
	\item \newversion{
		\linkdest{blockno}{$\blockno$}: 
		\emph{区块号码函数} 以一个树图 $\graph$ 和一个区块 $\block$ 为输入，输出区块 $\block$ 在该树图中所有区块的全序序号。
		该序号起始于 $0$ ，且对于创世块 $\gblock$ 和任意树图 $\graph$ ，$\blockno(\gblock;\graph)=0$ 始终成立。
		注意，$\blockno(\block;\graph)$ 取决于 $\graph$，区别于仅随 $\block$ 而定的 $\past(\block)$ 。
		因为 $\past(\block)$ 中的所有区块在全序上都先于 $\block$ ，则对于所有树图 $\graph$ 和指定树图所含的所有区块，$\blockno(\block;\graph)\ge \past(\block)$ 始终成立。
		此外，因为不同区块不会拥有相同的全序序号，当 $\block,\block'\in\graph$ 且 $\block\ne\block'$ 时，$\blockno(\block;\graph)\ne\blockno(\block';\graph)$ 一定成立。
		在不产生歧义的前提下，我们可能为了简洁性使用 $\blockno(\block)$ 来表达。
		%the \emph{block number function} takes a \tg $\graph$ and a block $\block$ as inputs and returns the index of $\block$ in the total order of blocks specified by $\graph$, where the index starts from $0$.
		%In particular, for the genesis block $\gblock$ and for every \tg $\graph$ there must be $\blockno(\gblock;\graph)=0$.
		%Note that $\blockno(\block;\graph)$ depends on $\graph$ and it is different from $\past(\block)$ which is fully determined by $\block$.
		%For every $\graph$ and $\block\in\graph$ there must be $\blockno(\block;\graph)\ge \past(\block)$ since all blocks in $\past(\block)$ precede $\block$ in the total order.
		%Furthermore, for $\block,\block'\in\graph$ and $\block\ne\block'$, there must be $\blockno(\block;\graph)\ne\blockno(\block';\graph)$ because distinct blocks cannot have identical index in the total order.
		%When the \tg $\graph$ is clear from context, we may write $\blockno(\block)$ for succinctness.
	}
	
	
	\item $\pivotf$: \emph{枢轴函数} 以一个区块 $\block$ 为输入，输出 $\block$ 所在纪元的所有枢轴块。
	%the \emph{pivot function} takes a block $\block$ as input and outputs the pivot block in the epoch of $\block$.
	
	
	\item $\senderf$: \emph{发送者函数} $\senderf$ 以一笔交易 $\tx$ 为输入，输出这笔交易的发送方地址。 
	
	
	\item \linkdest{rlp}{$\rlp$}: 将输入的随意长度的消息转换为结构化的二进制数据（即一个字节序列）并在其中嵌入消息的长度信息的序列化函数。更多细节可参考 \cite{ETH_yellow} 的附录B。 
	
	
	\item $\tolist$: 此函数的输入是一个以整数或位序列/字节序列为键、以整数为值的键值对集合。其以升序或字母次序输出非零值的键值组合。
	%this function takes a key/value set whose keys are integers or bit/byte sequences the values are integers. It outputs a sequence of key/value pairs for the entry with non-zero value in ascending order or lexicographical order of key.
	
	
	\item $\trie$: 该函数将任意长度的二进制字节序列 $\mathbf{s}$ 映射到一个 $256$ 比特的承诺，这个承诺可作为摘要代表一个以变种的 Merkle Patricia 树（Trie）形式存储 $\mathbf{s}$ 的数据库。
	
	
	\item $\kec$: Keccak 256 比特密码学（抗碰撞）哈希函数可将一个任意长度的字节序列映射到 $\B_{256}$ 里一个看似随机选取的二进制字符串。
	此外，我们假设 $\kec$ 是一个随机预言机；换言之，找到 $\kec$ 的一个随机的碰撞所需的预期尝试次数约为 $2^{128}$ 次，而找到一个指定的碰撞大约需要尝试 $2^{256}$ 次。
	相同地，$\kec512$ 代表Keccak 512 比特密码学哈希函数。
	%Similarly, $\kec512$ refers to the $512$-bit cryptographic hash function Keccak-512.
	
	
	\item $\pow$: 工作量证明函数，输入一个区块头，返回 $\B_{256}$ 里的一个标量。
	
	
	\item \newversion{$\quality$: 所给区块的工作量证明质量，即挖到该区块的不可能性（困难程度）。
		其以一个区块或区块头为输入，输出$\N_{256}$ 里的一个标量。
		本质上，一个区块头为 $\head=\head(\block)$ 的区块 $\block$ 质量为 $\quality(\block)\eqdef 
		\quality(\head)\eqdef 
		\left\lfloor 2^{256}/\left(\pow(\head) - \left[\head_n[1\dots127]\right]_2\times 2^{128} +1\right) \right\rfloor$ （除去少数边缘案例）。
		更多细节可参考 \ref{subsec:quality}。}
\end{itemize}


\subsection{价值}
为了激励共识节点维护 {\name} 网络的运转，并向用户收取资源消耗的费用，
%To incentivize the maintenance of the {\name} network and charge users for consumption of resources,
%原翻译：为了激励共识节点维护 {\name} 网络的运转和安全性，以及通过收费的方式调节用户使用资源的数量和优先级，
{\name} 定义了一个称为 Conflux Coin 或 \coin 的內部流通货币，符号缩写为 \coinsign。
{\name} 中货币的最小单位为 \unit，一个 \coin 等于 $10^{18}$ 个 \unit。
{\name} 系统能处理的所有的价值都必须是 Drip 的整倍数。
{\name} 系统中常用的货币单位如下：

\par
\begin{center}
	\begin{tabular}{cl}
		\toprule
		Drip 的倍数 & 名称 \\
		\midrule
		$10^{0~}$ & \unit \\
		% $10^{6}$ & TBD \\
		$10^{9~}$ & \gunit \\
		$10^{12}$ & \ucoinsign \\
		% $10^{15}$ & TBD \\
		$10^{18}$ & \coin (\coinsign) \\
		\bottomrule
	\end{tabular}
\end{center}








